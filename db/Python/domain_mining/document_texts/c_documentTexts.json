{
    "descriptions": [
        "It is quite easy to add new built-in modules to Python, if you know how to\nprogram in C.  Such . can do two things that can’t be\ndone directly in Python: they can implement new built-in object types, and they\ncan call C library functions and system calls..To support extensions, the Python API (Application Programmers Interface)\ndefines a set of functions, macros and variables that provide access to most\naspects of the Python run-time system.  The Python API is incorporated in a C\nsource file by including the header ...The compilation of an extension module depends on its intended use as well as on\nyour system setup; details are given in later chapters..Note.The C extension interface is specific to CPython, and extension modules do\nnot work on other Python implementations.  In many cases, it is possible to\navoid writing C extensions and preserve portability to other implementations.\nFor example, if your use case is calling C library functions or system calls,\nyou should consider using the . module or the . library rather than writing\ncustom C code.\nThese modules let you write Python code to interface with C code and are more\nportable between implementations of Python than writing and compiling a C\nextension module..Let’s create an extension module called . (the favorite food of Monty\nPython fans…) and let’s say we want to create a Python interface to the C\nlibrary function . .. This function takes a null-terminated\ncharacter string as argument and returns an integer.  We want this function to\nbe callable from Python as follows:.Begin by creating a file ..  (Historically, if a module is\ncalled ., the C file containing its implementation is called\n.; if the module name is very long, like ., the\nmodule name can be just ..).The first two lines of our file can be:.which pulls in the Python API (you can add a comment describing the purpose of\nthe module and a copyright notice if you like)..Note.Since Python may define some pre-processor definitions which affect the standard\nheaders on some systems, you . include . before any standard\nheaders are included..It is recommended to always define . before including\n..  See . for a description of this macro..All user-visible symbols defined by . have a prefix of . or\n., except those defined in standard header files. For convenience, and\nsince they are used extensively by the Python interpreter, .\nincludes a few standard header files: ., .,\n., and ..  If the latter header file does not exist on\nyour system, it declares the functions ., . and\n. directly..The next thing we add to our module file is the C function that will be called\nwhen the Python expression . is evaluated (we’ll see\nshortly how it ends up being called):.There is a straightforward translation from the argument list in Python (for\nexample, the single expression .) to the arguments passed to the C\nfunction.  The C function always has two arguments, conventionally named .\nand ...The . argument points to the module object for module-level functions;\nfor a method it would point to the object instance..The . argument will be a pointer to a Python tuple object containing the\narguments.  Each item of the tuple corresponds to an argument in the call’s\nargument list.  The arguments are Python objects — in order to do anything\nwith them in our C function we have to convert them to C values.  The function\n. in the Python API checks the argument types and\nconverts them to C values.  It uses a template string to determine the required\ntypes of the arguments as well as the types of the C variables into which to\nstore the converted values.  More about this later.. returns true (nonzero) if all arguments have the right\ntype and its components have been stored in the variables whose addresses are\npassed.  It returns false (zero) if an invalid argument list was passed.  In the\nlatter case it also raises an appropriate exception so the calling function can\nreturn . immediately (as we saw in the example)..An important convention throughout the Python interpreter is the following: when\na function fails, it should set an exception condition and return an error value\n(usually a . pointer).  Exceptions are stored in a static global variable\ninside the interpreter; if this variable is . no exception has occurred.  A\nsecond global variable stores the “associated value” of the exception (the\nsecond argument to .).  A third variable contains the stack\ntraceback in case the error originated in Python code.  These three variables\nare the C equivalents of the result in Python of . (see the\nsection on module . in the Python Library Reference).  It is important\nto know about them to understand how errors are passed around..The Python API defines a number of functions to set various types of exceptions..The most common one is ..  Its arguments are an exception\nobject and a C string.  The exception object is usually a predefined object like\n..  The C string indicates the cause of the error\nand is converted to a Python string object and stored as the “associated value”\nof the exception..Another useful function is ., which only takes an\nexception argument and constructs the associated value by inspection of the\nglobal variable ..  The most general function is\n., which takes two object arguments, the exception and\nits associated value.  You don’t need to . the objects passed\nto any of these functions..You can test non-destructively whether an exception has been set with\n..  This returns the current exception object, or .\nif no exception has occurred.  You normally don’t need to call\n. to see whether an error occurred in a function call,\nsince you should be able to tell from the return value..When a function . that calls another function . detects that the latter\nfails, . should itself return an error value (usually . or .).  It\nshould . call one of the . functions — one has already\nbeen called by .. .’s caller is then supposed to also return an error\nindication to . caller, again . calling ., and so on\n— the most detailed cause of the error was already reported by the function\nthat first detected it.  Once the error reaches the Python interpreter’s main\nloop, this aborts the currently executing Python code and tries to find an\nexception handler specified by the Python programmer..(There are situations where a module can actually give a more detailed error\nmessage by calling another . function, and in such cases it is\nfine to do so.  As a general rule, however, this is not necessary, and can cause\ninformation about the cause of the error to be lost: most operations can fail\nfor a variety of reasons.).To ignore an exception set by a function call that failed, the exception\ncondition must be cleared explicitly by calling ..  The only\ntime C code should call . is if it doesn’t want to pass the\nerror on to the interpreter but wants to handle it completely by itself\n(possibly by trying something else, or pretending nothing went wrong)..Every failing . call must be turned into an exception — the\ndirect caller of . (or .) must call\n. and return a failure indicator itself.  All the\nobject-creating functions (for example, .) already do\nthis, so this note is only relevant to those who call . directly..Also note that, with the important exception of . and\nfriends, functions that return an integer status usually return a positive value\nor zero for success and . for failure, like Unix system calls..Finally, be careful to clean up garbage (by making . or\n. calls for objects you have already created) when you return\nan error indicator!.The choice of which exception to raise is entirely yours.  There are predeclared\nC objects corresponding to all built-in Python exceptions, such as\n., which you can use directly. Of course, you\nshould choose exceptions wisely — don’t use . to mean\nthat a file couldn’t be opened (that should probably be .).\nIf something’s wrong with the argument list, the .\nfunction usually raises ..  If you have an argument whose\nvalue must be in a particular range or must satisfy other conditions,\n. is appropriate..You can also define a new exception that is unique to your module. For this, you\nusually declare a static object variable at the beginning of your file:.and initialize it in your module’s initialization function (.)\nwith an exception object:.Note that the Python name for the exception object is ..  The\n. function may create a class with the base class\nbeing . (unless another class is passed in instead of .),\ndescribed in ...Note also that the . variable retains a reference to the newly\ncreated exception class; this is intentional!  Since the exception could be\nremoved from the module by external code, an owned reference to the class is\nneeded to ensure that it will not be discarded, causing . to\nbecome a dangling pointer. Should it become a dangling pointer, C code which\nraises the exception could cause a core dump or other unintended side effects..We discuss the use of . as a function return type later in this\nsample..The . exception can be raised in your extension module using a\ncall to . as shown below:.Going back to our example function, you should now be able to understand this\nstatement:.It returns . (the error indicator for functions returning object pointers)\nif an error is detected in the argument list, relying on the exception set by\n..  Otherwise the string value of the argument has been\ncopied to the local variable ..  This is a pointer assignment and\nyou are not supposed to modify the string to which it points (so in Standard C,\nthe variable . should properly be declared as .)..The next statement is a call to the Unix function ., passing it\nthe string we just got from .:.Our . function must return the value of . as a\nPython object.  This is done using the function ...In this case, it will return an integer object.  (Yes, even integers are objects\non the heap in Python!).If you have a C function that returns no useful argument (a function returning\n.), the corresponding Python function must return ..   You\nneed this idiom to do so (which is implemented by the .\nmacro):. is the C name for the special Python object ..  It is a\ngenuine Python object rather than a . pointer, which means “error” in most\ncontexts, as we have seen..I promised to show how . is called from Python programs.\nFirst, we need to list its name and address in a “method table”:.Note the third entry (.).  This is a flag telling the interpreter\nthe calling convention to be used for the C function.  It should normally always\nbe . or .; a value of . means\nthat an obsolete variant of . is used..When using only ., the function should expect the Python-level\nparameters to be passed in as a tuple acceptable for parsing via\n.; more information on this function is provided below..The . bit may be set in the third field if keyword\narguments should be passed to the function.  In this case, the C function should\naccept a third . parameter which will be a dictionary of keywords.\nUse . to parse the arguments to such a\nfunction..The method table must be referenced in the module definition structure:.This structure, in turn, must be passed to the interpreter in the module’s\ninitialization function.  The initialization function must be named\n., where . is the name of the module, and should be the\nonly non-. item defined in the module file:.Note that PyMODINIT_FUNC declares the function as . return type,\ndeclares any special linkage declarations required by the platform, and for C++\ndeclares the function as ...When the Python program imports module . for the first time,\n. is called. (See below for comments about embedding Python.)\nIt calls ., which returns a module object, and\ninserts built-in function objects into the newly created module based upon the\ntable (an array of . structures) found in the module definition.\n. returns a pointer to the module object\nthat it creates.  It may abort with a fatal error for\ncertain errors, or return . if the module could not be initialized\nsatisfactorily. The init function must return the module object to its caller,\nso that it then gets inserted into ...When embedding Python, the . function is not called\nautomatically unless there’s an entry in the . table.\nTo add the module to the initialization table, use .,\noptionally followed by an import of the module:.Note.Removing entries from . or importing compiled modules into\nmultiple interpreters within a process (or following a . without an\nintervening .) can create problems for some extension modules.\nExtension module authors should exercise caution when initializing internal data\nstructures..A more substantial example module is included in the Python source distribution\nas ..  This file may be used as a  template or simply\nread as an example..Note.Unlike our . example, . uses .\n(new in Python 3.5), where a PyModuleDef structure is returned from\n., and creation of the module is left to the import machinery.\nFor details on multi-phase initialization, see ...There are two more things to do before you can use your new extension: compiling\nand linking it with the Python system.  If you use dynamic loading, the details\nmay depend on the style of dynamic loading your system uses; see the chapters\nabout building extension modules (chapter .) and additional\ninformation that pertains only to building on Windows (chapter\n.) for more information about this..If you can’t use dynamic loading, or if you want to make your module a permanent\npart of the Python interpreter, you will have to change the configuration setup\nand rebuild the interpreter.  Luckily, this is very simple on Unix: just place\nyour file (. for example) in the . directory\nof an unpacked source distribution, add a line to the file\n. describing your file:.and rebuild the interpreter by running . in the toplevel\ndirectory.  You can also run . in the .\nsubdirectory, but then you must first rebuild . there by running\n‘. Makefile’.  (This is necessary each time you change the\n. file.).If your module requires additional libraries to link with, these can be listed\non the line in the configuration file as well, for instance:.So far we have concentrated on making C functions callable from Python.  The\nreverse is also useful: calling Python functions from C. This is especially the\ncase for libraries that support so-called “callback” functions.  If a C\ninterface makes use of callbacks, the equivalent Python often needs to provide a\ncallback mechanism to the Python programmer; the implementation will require\ncalling the Python callback functions from a C callback.  Other uses are also\nimaginable..Fortunately, the Python interpreter is easily called recursively, and there is a\nstandard interface to call a Python function.  (I won’t dwell on how to call the\nPython parser with a particular string as input — if you’re interested, have a\nlook at the implementation of the . command line option in\n. from the Python source code.).Calling a Python function is easy.  First, the Python program must somehow pass\nyou the Python function object.  You should provide a function (or some other\ninterface) to do this.  When this function is called, save a pointer to the\nPython function object (be careful to . it!) in a global\nvariable — or wherever you see fit. For example, the following function might\nbe part of a module definition:.This function must be registered with the interpreter using the\n. flag; this is described in section ..  The\n. function and its arguments are documented in section\n...The macros . and . increment/decrement the\nreference count of an object and are safe in the presence of . pointers\n(but note that . will not be  . in this context).  More info on them\nin section ...Later, when it is time to call the function, you call the C function\n..  This function has two arguments, both pointers to\narbitrary Python objects: the Python function, and the argument list.  The\nargument list must always be a tuple object, whose length is the number of\narguments.  To call the Python function with no arguments, pass in ., or\nan empty tuple; to call it with one argument, pass a singleton tuple.\n. returns a tuple when its format string consists of zero\nor more format codes between parentheses.  For example:. returns a Python object pointer: this is the return\nvalue of the Python function.  . is\n“reference-count-neutral” with respect to its arguments.  In the example a new\ntuple was created to serve as the argument list, which is\n.-ed immediately after the .\ncall..The return value of . is “new”: either it is a brand\nnew object, or it is an existing object whose reference count has been\nincremented.  So, unless you want to save it in a global variable, you should\nsomehow . the result, even (especially!) if you are not\ninterested in its value..Before you do this, however, it is important to check that the return value\nisn’t ..  If it is, the Python function terminated by raising an exception.\nIf the C code that called . is called from Python, it\nshould now return an error indication to its Python caller, so the interpreter\ncan print a stack trace, or the calling Python code can handle the exception.\nIf this is not possible or desirable, the exception should be cleared by calling\n..  For example:.Depending on the desired interface to the Python callback function, you may also\nhave to provide an argument list to ..  In some cases\nthe argument list is also provided by the Python program, through the same\ninterface that specified the callback function.  It can then be saved and used\nin the same manner as the function object.  In other cases, you may have to\nconstruct a new tuple to pass as the argument list.  The simplest way to do this\nis to call ..  For example, if you want to pass an integral\nevent code, you might use the following code:.Note the placement of . immediately after the call, before\nthe error check!  Also note that strictly speaking this code is not complete:\n. may run out of memory, and this should be checked..You may also call a function with keyword arguments by using\n., which supports arguments and keyword arguments.  As in\nthe above example, we use . to construct the dictionary..The . function is declared as follows:.The . argument must be a tuple object containing an argument list passed\nfrom Python to a C function.  The . argument must be a format string,\nwhose syntax is explained in . in the Python/C API Reference\nManual.  The remaining arguments must be addresses of variables whose type is\ndetermined by the format string..Note that while . checks that the Python arguments have\nthe required types, it cannot check the validity of the addresses of C variables\npassed to the call: if you make mistakes there, your code will probably crash or\nat least overwrite random bits in memory.  So be careful!.Note that any Python object references which are provided to the caller are\n. references; do not decrement their reference count!.Some example calls:.The . function is declared as follows:.The . and . parameters are identical to those of the\n. function.  The . parameter is the dictionary of\nkeywords received as the third parameter from the Python runtime.  The .\nparameter is a .-terminated list of strings which identify the parameters;\nthe names are matched with the type information from . from left to\nright.  On success, . returns true, otherwise\nit returns false and raises an appropriate exception..Note.Nested tuples cannot be parsed when using keyword arguments!  Keyword parameters\npassed in which are not present in the . will cause . to\nbe raised..Here is an example module which uses keywords, based on an example by Geoff\nPhilbrick (.):.This function is the counterpart to ..  It is declared\nas follows:.It recognizes a set of format units similar to the ones recognized by\n., but the arguments (which are input to the function,\nnot output) must not be pointers, just values.  It returns a new Python object,\nsuitable for returning from a C function called from Python..One difference with .: while the latter requires its\nfirst argument to be a tuple (since Python argument lists are always represented\nas tuples internally), . does not always build a tuple.  It\nbuilds a tuple only if its format string contains two or more format units. If\nthe format string is empty, it returns .; if it contains exactly one\nformat unit, it returns whatever object is described by that format unit.  To\nforce it to return a tuple of size 0 or one, parenthesize the format string..Examples (to the left the call, to the right the resulting Python value):.In languages like C or C++, the programmer is responsible for dynamic allocation\nand deallocation of memory on the heap.  In C, this is done using the functions\n. and ..  In C++, the operators . and\n. are used with essentially the same meaning and we’ll restrict\nthe following discussion to the C case..Every block of memory allocated with . should eventually be\nreturned to the pool of available memory by exactly one call to ..\nIt is important to call . at the right time.  If a block’s address\nis forgotten but . is not called for it, the memory it occupies\ncannot be reused until the program terminates.  This is called a ..  On the other hand, if a program calls . for a block and then\ncontinues to use the block, it creates a conflict with re-use of the block\nthrough another . call.  This is called ..\nIt has the same bad consequences as referencing uninitialized data — core\ndumps, wrong results, mysterious crashes..Common causes of memory leaks are unusual paths through the code.  For instance,\na function may allocate a block of memory, do some calculation, and then free\nthe block again.  Now a change in the requirements for the function may add a\ntest to the calculation that detects an error condition and can return\nprematurely from the function.  It’s easy to forget to free the allocated memory\nblock when taking this premature exit, especially when it is added later to the\ncode.  Such leaks, once introduced, often go undetected for a long time: the\nerror exit is taken only in a small fraction of all calls, and most modern\nmachines have plenty of virtual memory, so the leak only becomes apparent in a\nlong-running process that uses the leaking function frequently.  Therefore, it’s\nimportant to prevent leaks from happening by having a coding convention or\nstrategy that minimizes this kind of errors..Since Python makes heavy use of . and ., it needs a\nstrategy to avoid memory leaks as well as the use of freed memory.  The chosen\nmethod is called ..  The principle is simple: every\nobject contains a counter, which is incremented when a reference to the object\nis stored somewhere, and which is decremented when a reference to it is deleted.\nWhen the counter reaches zero, the last reference to the object has been deleted\nand the object is freed..An alternative strategy is called ..\n(Sometimes, reference counting is also referred to as a garbage collection\nstrategy, hence my use of “automatic” to distinguish the two.)  The big\nadvantage of automatic garbage collection is that the user doesn’t need to call\n. explicitly.  (Another claimed advantage is an improvement in speed\nor memory usage — this is no hard fact however.)  The disadvantage is that for\nC, there is no truly portable automatic garbage collector, while reference\ncounting can be implemented portably (as long as the functions .\nand . are available — which the C Standard guarantees). Maybe some\nday a sufficiently portable automatic garbage collector will be available for C.\nUntil then, we’ll have to live with reference counts..While Python uses the traditional reference counting implementation, it also\noffers a cycle detector that works to detect reference cycles.  This allows\napplications to not worry about creating direct or indirect circular references;\nthese are the weakness of garbage collection implemented using only reference\ncounting.  Reference cycles consist of objects which contain (possibly indirect)\nreferences to themselves, so that each object in the cycle has a reference count\nwhich is non-zero.  Typical reference counting implementations are not able to\nreclaim the memory belonging to any objects in a reference cycle, or referenced\nfrom the objects in the cycle, even though there are no further references to\nthe cycle itself..The cycle detector is able to detect garbage cycles and can reclaim them.\nThe . module exposes a way to run the detector (the\n. function), as well as configuration\ninterfaces and the ability to disable the detector at runtime..There are two macros, . and ., which handle the\nincrementing and decrementing of the reference count. . also\nfrees the object when the count reaches zero. For flexibility, it doesn’t call\n. directly — rather, it makes a call through a function pointer in\nthe object’s ..  For this purpose (and others), every object\nalso contains a pointer to its type object..The big question now remains: when to use . and .?\nLet’s first introduce some terms.  Nobody “owns” an object; however, you can\n. to an object.  An object’s reference count is now defined\nas the number of owned references to it.  The owner of a reference is\nresponsible for calling . when the reference is no longer\nneeded.  Ownership of a reference can be transferred.  There are three ways to\ndispose of an owned reference: pass it on, store it, or call ..\nForgetting to dispose of an owned reference creates a memory leak..It is also possible to . . a reference to an object.  The\nborrower of a reference should not call ..  The borrower must\nnot hold on to the object longer than the owner from which it was borrowed.\nUsing a borrowed reference after the owner has disposed of it risks using freed\nmemory and should be avoided completely ...The advantage of borrowing over owning a reference is that you don’t need to\ntake care of disposing of the reference on all possible paths through the code\n— in other words, with a borrowed reference you don’t run the risk of leaking\nwhen a premature exit is taken.  The disadvantage of borrowing over owning is\nthat there are some subtle situations where in seemingly correct code a borrowed\nreference can be used after the owner from which it was borrowed has in fact\ndisposed of it..A borrowed reference can be changed into an owned reference by calling\n..  This does not affect the status of the owner from which the\nreference was borrowed — it creates a new owned reference, and gives full\nowner responsibilities (the new owner must dispose of the reference properly, as\nwell as the previous owner)..Whenever an object reference is passed into or out of a function, it is part of\nthe function’s interface specification whether ownership is transferred with the\nreference or not..Most functions that return a reference to an object pass on ownership with the\nreference.  In particular, all functions whose function it is to create a new\nobject, such as . and ., pass\nownership to the receiver.  Even if the object is not actually new, you still\nreceive ownership of a new reference to that object.  For instance,\n. maintains a cache of popular values and can return a\nreference to a cached item..Many functions that extract objects from other objects also transfer ownership\nwith the reference, for instance ..  The picture\nis less clear, here, however, since a few common routines are exceptions:\n., ., ., and\n. all return references that you borrow from the\ntuple, list or dictionary..The function . also returns a borrowed reference, even\nthough it may actually create the object it returns: this is possible because an\nowned reference to the object is stored in ...When you pass an object reference into another function, in general, the\nfunction borrows the reference from you — if it needs to store it, it will use\n. to become an independent owner.  There are exactly two\nimportant exceptions to this rule: . and\n..  These functions take over ownership of the item passed\nto them — even if they fail!  (Note that . and friends\ndon’t take over ownership — they are “normal.”).When a C function is called from Python, it borrows references to its arguments\nfrom the caller.  The caller owns a reference to the object, so the borrowed\nreference’s lifetime is guaranteed until the function returns.  Only when such a\nborrowed reference must be stored or passed on, it must be turned into an owned\nreference by calling ...The object reference returned from a C function that is called from Python must\nbe an owned reference — ownership is transferred from the function to its\ncaller..There are a few situations where seemingly harmless use of a borrowed reference\ncan lead to problems.  These all have to do with implicit invocations of the\ninterpreter, which can cause the owner of a reference to dispose of it..The first and most important case to know about is using . on\nan unrelated object while borrowing a reference to a list item.  For instance:.This function first borrows a reference to ., then replaces\n. with the value ., and finally prints the borrowed reference.\nLooks harmless, right?  But it’s not!.Let’s follow the control flow into ..  The list owns\nreferences to all its items, so when item 1 is replaced, it has to dispose of\nthe original item 1.  Now let’s suppose the original item 1 was an instance of a\nuser-defined class, and let’s further suppose that the class defined a\n. method.  If this class instance has a reference count of 1,\ndisposing of it will call its . method..Since it is written in Python, the . method can execute arbitrary\nPython code.  Could it perhaps do something to invalidate the reference to\n. in .?  You bet!  Assuming that the list passed into\n. is accessible to the . method, it could execute a\nstatement to the effect of ., and assuming this was the last\nreference to that object, it would free the memory associated with it, thereby\ninvalidating ...The solution, once you know the source of the problem, is easy: temporarily\nincrement the reference count.  The correct version of the function reads:.This is a true story.  An older version of Python contained variants of this bug\nand someone spent a considerable amount of time in a C debugger to figure out\nwhy his . methods would fail….The second case of problems with a borrowed reference is a variant involving\nthreads.  Normally, multiple threads in the Python interpreter can’t get in each\nother’s way, because there is a global lock protecting Python’s entire object\nspace.  However, it is possible to temporarily release this lock using the macro\n., and to re-acquire it using\n..  This is common around blocking I/O calls, to\nlet other threads use the processor while waiting for the I/O to complete.\nObviously, the following function has the same problem as the previous one:.In general, functions that take object references as arguments do not expect you\nto pass them . pointers, and will dump core (or cause later core dumps) if\nyou do so.  Functions that return object references generally return . only\nto indicate that an exception occurred.  The reason for not testing for .\narguments is that functions often pass the objects they receive on to other\nfunction — if each function were to test for ., there would be a lot of\nredundant tests and the code would run more slowly..It is better to test for . only at the “source:” when a pointer that may be\n. is received, for example, from . or from a function that\nmay raise an exception..The macros . and . do not check for .\npointers — however, their variants . and .\ndo..The macros for checking for a particular object type (.) don’t\ncheck for . pointers — again, there is much code that calls several of\nthese in a row to test an object against various different expected types, and\nthis would generate redundant tests.  There are no variants with .\nchecking..The C function calling mechanism guarantees that the argument list passed to C\nfunctions (. in the examples) is never . — in fact it guarantees\nthat it is always a tuple ...It is a severe error to ever let a . pointer “escape” to the Python user..It is possible to write extension modules in C++.  Some restrictions apply.  If\nthe main program (the Python interpreter) is compiled and linked by the C\ncompiler, global or static objects with constructors cannot be used.  This is\nnot a problem if the main program is linked by the C++ compiler.  Functions that\nwill be called by the Python interpreter (in particular, module initialization\nfunctions) have to be declared using .. It is unnecessary to\nenclose the Python header files in . — they use this form\nalready if the symbol . is defined (all recent C++ compilers\ndefine this symbol)..Many extension modules just provide new functions and types to be used from\nPython, but sometimes the code in an extension module can be useful for other\nextension modules. For example, an extension module could implement a type\n“collection” which works like lists without order. Just like the standard Python\nlist type has a C API which permits extension modules to create and manipulate\nlists, this new collection type should have a set of C functions for direct\nmanipulation from other extension modules..At first sight this seems easy: just write the functions (without declaring them\n., of course), provide an appropriate header file, and document\nthe C API. And in fact this would work if all extension modules were always\nlinked statically with the Python interpreter. When modules are used as shared\nlibraries, however, the symbols defined in one module may not be visible to\nanother module. The details of visibility depend on the operating system; some\nsystems use one global namespace for the Python interpreter and all extension\nmodules (Windows, for example), whereas others require an explicit list of\nimported symbols at module link time (AIX is one example), or offer a choice of\ndifferent strategies (most Unices). And even if symbols are globally visible,\nthe module whose functions one wishes to call might not have been loaded yet!.Portability therefore requires not to make any assumptions about symbol\nvisibility. This means that all symbols in extension modules should be declared\n., except for the module’s initialization function, in order to\navoid name clashes with other extension modules (as discussed in section\n.). And it means that symbols that . be accessible from\nother extension modules must be exported in a different way..Python provides a special mechanism to pass C-level information (pointers) from\none extension module to another one: Capsules. A Capsule is a Python data type\nwhich stores a pointer (.).  Capsules can only be created and\naccessed via their C API, but they can be passed around like any other Python\nobject. In particular,  they can be assigned to a name in an extension module’s\nnamespace. Other extension modules can then import this module, retrieve the\nvalue of this name, and then retrieve the pointer from the Capsule..There are many ways in which Capsules can be used to export the C API of an\nextension module. Each function could get its own Capsule, or all C API pointers\ncould be stored in an array whose address is published in a Capsule. And the\nvarious tasks of storing and retrieving the pointers can be distributed in\ndifferent ways between the module providing the code and the client modules..Whichever method you choose, it’s important to name your Capsules properly.\nThe function . takes a name parameter\n(.); you’re permitted to pass in a . name, but\nwe strongly encourage you to specify a name.  Properly named Capsules provide\na degree of runtime type-safety; there is no feasible way to tell one unnamed\nCapsule from another..In particular, Capsules used to expose C APIs should be given a name following\nthis convention:.The convenience function . makes it easy to\nload a C API provided via a Capsule, but only if the Capsule’s name\nmatches this convention.  This behavior gives C API users a high degree\nof certainty that the Capsule they load contains the correct C API..The following example demonstrates an approach that puts most of the burden on\nthe writer of the exporting module, which is appropriate for commonly used\nlibrary modules. It stores all C API pointers (just one in the example!) in an\narray of . pointers which becomes the value of a Capsule. The header\nfile corresponding to the module provides a macro that takes care of importing\nthe module and retrieving its C API pointers; client modules only have to call\nthis macro before accessing the C API..The exporting module is a modification of the . module from section\n.. The function . does not call\nthe C library function . directly, but a function\n., which would of course do something more complicated in\nreality (such as adding “spam” to every command). This function\n. is also exported to other extension modules..The function . is a plain C function, declared\n. like everything else:.The function . is modified in a trivial way:.In the beginning of the module, right after the line.two more lines must be added:.The . is used to tell the header file that it is being included in the\nexporting module, not a client module. Finally, the module’s initialization\nfunction must take care of initializing the C API pointer array:.Note that . is declared .; otherwise the pointer\narray would disappear when . terminates!.The bulk of the work is in the header file ., which looks\nlike this:.All that a client module must do in order to have access to the function\n. is to call the function (or rather macro)\n. in its initialization function:.The main disadvantage of this approach is that the file . is\nrather complicated. However, the basic structure is the same for each function\nthat is exported, so it has to be learned only once..Finally it should be mentioned that Capsules offer additional functionality,\nwhich is especially useful for memory allocation and deallocation of the pointer\nstored in a Capsule. The details are described in the Python/C API Reference\nManual in the section . and in the implementation of Capsules (files\n. and . in the Python source\ncode distribution)..Footnotes.An interface for this function already exists in the standard module .\n— it was chosen as a simple and straightforward example..The metaphor of “borrowing” a reference is not completely correct: the owner\nstill has a copy of the reference..Checking that the reference count is at least 1 . — the\nreference count itself could be in freed memory and may thus be reused for\nanother object!.These guarantees don’t hold when you use the “old” style calling convention —\nthis is still found in much existing code.",
        "It is quite easy to add new built-in modules to Python, if you know how to\nprogram in C.  Such . can do two things that can’t be\ndone directly in Python: they can implement new built-in object types, and they\ncan call C library functions and system calls..To support extensions, the Python API (Application Programmers Interface)\ndefines a set of functions, macros and variables that provide access to most\naspects of the Python run-time system.  The Python API is incorporated in a C\nsource file by including the header ...The compilation of an extension module depends on its intended use as well as on\nyour system setup; details are given in later chapters..Note.The C extension interface is specific to CPython, and extension modules do\nnot work on other Python implementations.  In many cases, it is possible to\navoid writing C extensions and preserve portability to other implementations.\nFor example, if your use case is calling C library functions or system calls,\nyou should consider using the . module or the . library rather than writing\ncustom C code.\nThese modules let you write Python code to interface with C code and are more\nportable between implementations of Python than writing and compiling a C\nextension module..Let’s create an extension module called . (the favorite food of Monty\nPython fans…) and let’s say we want to create a Python interface to the C\nlibrary function . .. This function takes a null-terminated\ncharacter string as argument and returns an integer.  We want this function to\nbe callable from Python as follows:.Begin by creating a file ..  (Historically, if a module is\ncalled ., the C file containing its implementation is called\n.; if the module name is very long, like ., the\nmodule name can be just ..).The first two lines of our file can be:.which pulls in the Python API (you can add a comment describing the purpose of\nthe module and a copyright notice if you like)..Note.Since Python may define some pre-processor definitions which affect the standard\nheaders on some systems, you . include . before any standard\nheaders are included..It is recommended to always define . before including\n..  See . for a description of this macro..All user-visible symbols defined by . have a prefix of . or\n., except those defined in standard header files. For convenience, and\nsince they are used extensively by the Python interpreter, .\nincludes a few standard header files: ., .,\n., and ..  If the latter header file does not exist on\nyour system, it declares the functions ., . and\n. directly..The next thing we add to our module file is the C function that will be called\nwhen the Python expression . is evaluated (we’ll see\nshortly how it ends up being called):.There is a straightforward translation from the argument list in Python (for\nexample, the single expression .) to the arguments passed to the C\nfunction.  The C function always has two arguments, conventionally named .\nand ...The . argument points to the module object for module-level functions;\nfor a method it would point to the object instance..The . argument will be a pointer to a Python tuple object containing the\narguments.  Each item of the tuple corresponds to an argument in the call’s\nargument list.  The arguments are Python objects — in order to do anything\nwith them in our C function we have to convert them to C values.  The function\n. in the Python API checks the argument types and\nconverts them to C values.  It uses a template string to determine the required\ntypes of the arguments as well as the types of the C variables into which to\nstore the converted values.  More about this later.. returns true (nonzero) if all arguments have the right\ntype and its components have been stored in the variables whose addresses are\npassed.  It returns false (zero) if an invalid argument list was passed.  In the\nlatter case it also raises an appropriate exception so the calling function can\nreturn . immediately (as we saw in the example)..An important convention throughout the Python interpreter is the following: when\na function fails, it should set an exception condition and return an error value\n(usually a . pointer).  Exceptions are stored in a static global variable\ninside the interpreter; if this variable is . no exception has occurred.  A\nsecond global variable stores the “associated value” of the exception (the\nsecond argument to .).  A third variable contains the stack\ntraceback in case the error originated in Python code.  These three variables\nare the C equivalents of the result in Python of . (see the\nsection on module . in the Python Library Reference).  It is important\nto know about them to understand how errors are passed around..The Python API defines a number of functions to set various types of exceptions..The most common one is ..  Its arguments are an exception\nobject and a C string.  The exception object is usually a predefined object like\n..  The C string indicates the cause of the error\nand is converted to a Python string object and stored as the “associated value”\nof the exception..Another useful function is ., which only takes an\nexception argument and constructs the associated value by inspection of the\nglobal variable ..  The most general function is\n., which takes two object arguments, the exception and\nits associated value.  You don’t need to . the objects passed\nto any of these functions..You can test non-destructively whether an exception has been set with\n..  This returns the current exception object, or .\nif no exception has occurred.  You normally don’t need to call\n. to see whether an error occurred in a function call,\nsince you should be able to tell from the return value..When a function . that calls another function . detects that the latter\nfails, . should itself return an error value (usually . or .).  It\nshould . call one of the . functions — one has already\nbeen called by .. .’s caller is then supposed to also return an error\nindication to . caller, again . calling ., and so on\n— the most detailed cause of the error was already reported by the function\nthat first detected it.  Once the error reaches the Python interpreter’s main\nloop, this aborts the currently executing Python code and tries to find an\nexception handler specified by the Python programmer..(There are situations where a module can actually give a more detailed error\nmessage by calling another . function, and in such cases it is\nfine to do so.  As a general rule, however, this is not necessary, and can cause\ninformation about the cause of the error to be lost: most operations can fail\nfor a variety of reasons.).To ignore an exception set by a function call that failed, the exception\ncondition must be cleared explicitly by calling ..  The only\ntime C code should call . is if it doesn’t want to pass the\nerror on to the interpreter but wants to handle it completely by itself\n(possibly by trying something else, or pretending nothing went wrong)..Every failing . call must be turned into an exception — the\ndirect caller of . (or .) must call\n. and return a failure indicator itself.  All the\nobject-creating functions (for example, .) already do\nthis, so this note is only relevant to those who call . directly..Also note that, with the important exception of . and\nfriends, functions that return an integer status usually return a positive value\nor zero for success and . for failure, like Unix system calls..Finally, be careful to clean up garbage (by making . or\n. calls for objects you have already created) when you return\nan error indicator!.The choice of which exception to raise is entirely yours.  There are predeclared\nC objects corresponding to all built-in Python exceptions, such as\n., which you can use directly. Of course, you\nshould choose exceptions wisely — don’t use . to mean\nthat a file couldn’t be opened (that should probably be .).\nIf something’s wrong with the argument list, the .\nfunction usually raises ..  If you have an argument whose\nvalue must be in a particular range or must satisfy other conditions,\n. is appropriate..You can also define a new exception that is unique to your module. For this, you\nusually declare a static object variable at the beginning of your file:.and initialize it in your module’s initialization function (.)\nwith an exception object:.Note that the Python name for the exception object is ..  The\n. function may create a class with the base class\nbeing . (unless another class is passed in instead of .),\ndescribed in ...Note also that the . variable retains a reference to the newly\ncreated exception class; this is intentional!  Since the exception could be\nremoved from the module by external code, an owned reference to the class is\nneeded to ensure that it will not be discarded, causing . to\nbecome a dangling pointer. Should it become a dangling pointer, C code which\nraises the exception could cause a core dump or other unintended side effects..We discuss the use of . as a function return type later in this\nsample..The . exception can be raised in your extension module using a\ncall to . as shown below:.Going back to our example function, you should now be able to understand this\nstatement:.It returns . (the error indicator for functions returning object pointers)\nif an error is detected in the argument list, relying on the exception set by\n..  Otherwise the string value of the argument has been\ncopied to the local variable ..  This is a pointer assignment and\nyou are not supposed to modify the string to which it points (so in Standard C,\nthe variable . should properly be declared as .)..The next statement is a call to the Unix function ., passing it\nthe string we just got from .:.Our . function must return the value of . as a\nPython object.  This is done using the function ...In this case, it will return an integer object.  (Yes, even integers are objects\non the heap in Python!).If you have a C function that returns no useful argument (a function returning\n.), the corresponding Python function must return ..   You\nneed this idiom to do so (which is implemented by the .\nmacro):. is the C name for the special Python object ..  It is a\ngenuine Python object rather than a . pointer, which means “error” in most\ncontexts, as we have seen..I promised to show how . is called from Python programs.\nFirst, we need to list its name and address in a “method table”:.Note the third entry (.).  This is a flag telling the interpreter\nthe calling convention to be used for the C function.  It should normally always\nbe . or .; a value of . means\nthat an obsolete variant of . is used..When using only ., the function should expect the Python-level\nparameters to be passed in as a tuple acceptable for parsing via\n.; more information on this function is provided below..The . bit may be set in the third field if keyword\narguments should be passed to the function.  In this case, the C function should\naccept a third . parameter which will be a dictionary of keywords.\nUse . to parse the arguments to such a\nfunction..The method table must be referenced in the module definition structure:.This structure, in turn, must be passed to the interpreter in the module’s\ninitialization function.  The initialization function must be named\n., where . is the name of the module, and should be the\nonly non-. item defined in the module file:.Note that PyMODINIT_FUNC declares the function as . return type,\ndeclares any special linkage declarations required by the platform, and for C++\ndeclares the function as ...When the Python program imports module . for the first time,\n. is called. (See below for comments about embedding Python.)\nIt calls ., which returns a module object, and\ninserts built-in function objects into the newly created module based upon the\ntable (an array of . structures) found in the module definition.\n. returns a pointer to the module object\nthat it creates.  It may abort with a fatal error for\ncertain errors, or return . if the module could not be initialized\nsatisfactorily. The init function must return the module object to its caller,\nso that it then gets inserted into ...When embedding Python, the . function is not called\nautomatically unless there’s an entry in the . table.\nTo add the module to the initialization table, use .,\noptionally followed by an import of the module:.Note.Removing entries from . or importing compiled modules into\nmultiple interpreters within a process (or following a . without an\nintervening .) can create problems for some extension modules.\nExtension module authors should exercise caution when initializing internal data\nstructures..A more substantial example module is included in the Python source distribution\nas ..  This file may be used as a  template or simply\nread as an example..Note.Unlike our . example, . uses .\n(new in Python 3.5), where a PyModuleDef structure is returned from\n., and creation of the module is left to the import machinery.\nFor details on multi-phase initialization, see ...There are two more things to do before you can use your new extension: compiling\nand linking it with the Python system.  If you use dynamic loading, the details\nmay depend on the style of dynamic loading your system uses; see the chapters\nabout building extension modules (chapter .) and additional\ninformation that pertains only to building on Windows (chapter\n.) for more information about this..If you can’t use dynamic loading, or if you want to make your module a permanent\npart of the Python interpreter, you will have to change the configuration setup\nand rebuild the interpreter.  Luckily, this is very simple on Unix: just place\nyour file (. for example) in the . directory\nof an unpacked source distribution, add a line to the file\n. describing your file:.and rebuild the interpreter by running . in the toplevel\ndirectory.  You can also run . in the .\nsubdirectory, but then you must first rebuild . there by running\n‘. Makefile’.  (This is necessary each time you change the\n. file.).If your module requires additional libraries to link with, these can be listed\non the line in the configuration file as well, for instance:.So far we have concentrated on making C functions callable from Python.  The\nreverse is also useful: calling Python functions from C. This is especially the\ncase for libraries that support so-called “callback” functions.  If a C\ninterface makes use of callbacks, the equivalent Python often needs to provide a\ncallback mechanism to the Python programmer; the implementation will require\ncalling the Python callback functions from a C callback.  Other uses are also\nimaginable..Fortunately, the Python interpreter is easily called recursively, and there is a\nstandard interface to call a Python function.  (I won’t dwell on how to call the\nPython parser with a particular string as input — if you’re interested, have a\nlook at the implementation of the . command line option in\n. from the Python source code.).Calling a Python function is easy.  First, the Python program must somehow pass\nyou the Python function object.  You should provide a function (or some other\ninterface) to do this.  When this function is called, save a pointer to the\nPython function object (be careful to . it!) in a global\nvariable — or wherever you see fit. For example, the following function might\nbe part of a module definition:.This function must be registered with the interpreter using the\n. flag; this is described in section ..  The\n. function and its arguments are documented in section\n...The macros . and . increment/decrement the\nreference count of an object and are safe in the presence of . pointers\n(but note that . will not be  . in this context).  More info on them\nin section ...Later, when it is time to call the function, you call the C function\n..  This function has two arguments, both pointers to\narbitrary Python objects: the Python function, and the argument list.  The\nargument list must always be a tuple object, whose length is the number of\narguments.  To call the Python function with no arguments, pass in ., or\nan empty tuple; to call it with one argument, pass a singleton tuple.\n. returns a tuple when its format string consists of zero\nor more format codes between parentheses.  For example:. returns a Python object pointer: this is the return\nvalue of the Python function.  . is\n“reference-count-neutral” with respect to its arguments.  In the example a new\ntuple was created to serve as the argument list, which is\n.-ed immediately after the .\ncall..The return value of . is “new”: either it is a brand\nnew object, or it is an existing object whose reference count has been\nincremented.  So, unless you want to save it in a global variable, you should\nsomehow . the result, even (especially!) if you are not\ninterested in its value..Before you do this, however, it is important to check that the return value\nisn’t ..  If it is, the Python function terminated by raising an exception.\nIf the C code that called . is called from Python, it\nshould now return an error indication to its Python caller, so the interpreter\ncan print a stack trace, or the calling Python code can handle the exception.\nIf this is not possible or desirable, the exception should be cleared by calling\n..  For example:.Depending on the desired interface to the Python callback function, you may also\nhave to provide an argument list to ..  In some cases\nthe argument list is also provided by the Python program, through the same\ninterface that specified the callback function.  It can then be saved and used\nin the same manner as the function object.  In other cases, you may have to\nconstruct a new tuple to pass as the argument list.  The simplest way to do this\nis to call ..  For example, if you want to pass an integral\nevent code, you might use the following code:.Note the placement of . immediately after the call, before\nthe error check!  Also note that strictly speaking this code is not complete:\n. may run out of memory, and this should be checked..You may also call a function with keyword arguments by using\n., which supports arguments and keyword arguments.  As in\nthe above example, we use . to construct the dictionary..The . function is declared as follows:.The . argument must be a tuple object containing an argument list passed\nfrom Python to a C function.  The . argument must be a format string,\nwhose syntax is explained in . in the Python/C API Reference\nManual.  The remaining arguments must be addresses of variables whose type is\ndetermined by the format string..Note that while . checks that the Python arguments have\nthe required types, it cannot check the validity of the addresses of C variables\npassed to the call: if you make mistakes there, your code will probably crash or\nat least overwrite random bits in memory.  So be careful!.Note that any Python object references which are provided to the caller are\n. references; do not decrement their reference count!.Some example calls:.The . function is declared as follows:.The . and . parameters are identical to those of the\n. function.  The . parameter is the dictionary of\nkeywords received as the third parameter from the Python runtime.  The .\nparameter is a .-terminated list of strings which identify the parameters;\nthe names are matched with the type information from . from left to\nright.  On success, . returns true, otherwise\nit returns false and raises an appropriate exception..Note.Nested tuples cannot be parsed when using keyword arguments!  Keyword parameters\npassed in which are not present in the . will cause . to\nbe raised..Here is an example module which uses keywords, based on an example by Geoff\nPhilbrick (.):.This function is the counterpart to ..  It is declared\nas follows:.It recognizes a set of format units similar to the ones recognized by\n., but the arguments (which are input to the function,\nnot output) must not be pointers, just values.  It returns a new Python object,\nsuitable for returning from a C function called from Python..One difference with .: while the latter requires its\nfirst argument to be a tuple (since Python argument lists are always represented\nas tuples internally), . does not always build a tuple.  It\nbuilds a tuple only if its format string contains two or more format units. If\nthe format string is empty, it returns .; if it contains exactly one\nformat unit, it returns whatever object is described by that format unit.  To\nforce it to return a tuple of size 0 or one, parenthesize the format string..Examples (to the left the call, to the right the resulting Python value):.In languages like C or C++, the programmer is responsible for dynamic allocation\nand deallocation of memory on the heap.  In C, this is done using the functions\n. and ..  In C++, the operators . and\n. are used with essentially the same meaning and we’ll restrict\nthe following discussion to the C case..Every block of memory allocated with . should eventually be\nreturned to the pool of available memory by exactly one call to ..\nIt is important to call . at the right time.  If a block’s address\nis forgotten but . is not called for it, the memory it occupies\ncannot be reused until the program terminates.  This is called a ..  On the other hand, if a program calls . for a block and then\ncontinues to use the block, it creates a conflict with re-use of the block\nthrough another . call.  This is called ..\nIt has the same bad consequences as referencing uninitialized data — core\ndumps, wrong results, mysterious crashes..Common causes of memory leaks are unusual paths through the code.  For instance,\na function may allocate a block of memory, do some calculation, and then free\nthe block again.  Now a change in the requirements for the function may add a\ntest to the calculation that detects an error condition and can return\nprematurely from the function.  It’s easy to forget to free the allocated memory\nblock when taking this premature exit, especially when it is added later to the\ncode.  Such leaks, once introduced, often go undetected for a long time: the\nerror exit is taken only in a small fraction of all calls, and most modern\nmachines have plenty of virtual memory, so the leak only becomes apparent in a\nlong-running process that uses the leaking function frequently.  Therefore, it’s\nimportant to prevent leaks from happening by having a coding convention or\nstrategy that minimizes this kind of errors..Since Python makes heavy use of . and ., it needs a\nstrategy to avoid memory leaks as well as the use of freed memory.  The chosen\nmethod is called ..  The principle is simple: every\nobject contains a counter, which is incremented when a reference to the object\nis stored somewhere, and which is decremented when a reference to it is deleted.\nWhen the counter reaches zero, the last reference to the object has been deleted\nand the object is freed..An alternative strategy is called ..\n(Sometimes, reference counting is also referred to as a garbage collection\nstrategy, hence my use of “automatic” to distinguish the two.)  The big\nadvantage of automatic garbage collection is that the user doesn’t need to call\n. explicitly.  (Another claimed advantage is an improvement in speed\nor memory usage — this is no hard fact however.)  The disadvantage is that for\nC, there is no truly portable automatic garbage collector, while reference\ncounting can be implemented portably (as long as the functions .\nand . are available — which the C Standard guarantees). Maybe some\nday a sufficiently portable automatic garbage collector will be available for C.\nUntil then, we’ll have to live with reference counts..While Python uses the traditional reference counting implementation, it also\noffers a cycle detector that works to detect reference cycles.  This allows\napplications to not worry about creating direct or indirect circular references;\nthese are the weakness of garbage collection implemented using only reference\ncounting.  Reference cycles consist of objects which contain (possibly indirect)\nreferences to themselves, so that each object in the cycle has a reference count\nwhich is non-zero.  Typical reference counting implementations are not able to\nreclaim the memory belonging to any objects in a reference cycle, or referenced\nfrom the objects in the cycle, even though there are no further references to\nthe cycle itself..The cycle detector is able to detect garbage cycles and can reclaim them.\nThe . module exposes a way to run the detector (the\n. function), as well as configuration\ninterfaces and the ability to disable the detector at runtime..There are two macros, . and ., which handle the\nincrementing and decrementing of the reference count. . also\nfrees the object when the count reaches zero. For flexibility, it doesn’t call\n. directly — rather, it makes a call through a function pointer in\nthe object’s ..  For this purpose (and others), every object\nalso contains a pointer to its type object..The big question now remains: when to use . and .?\nLet’s first introduce some terms.  Nobody “owns” an object; however, you can\n. to an object.  An object’s reference count is now defined\nas the number of owned references to it.  The owner of a reference is\nresponsible for calling . when the reference is no longer\nneeded.  Ownership of a reference can be transferred.  There are three ways to\ndispose of an owned reference: pass it on, store it, or call ..\nForgetting to dispose of an owned reference creates a memory leak..It is also possible to . . a reference to an object.  The\nborrower of a reference should not call ..  The borrower must\nnot hold on to the object longer than the owner from which it was borrowed.\nUsing a borrowed reference after the owner has disposed of it risks using freed\nmemory and should be avoided completely ...The advantage of borrowing over owning a reference is that you don’t need to\ntake care of disposing of the reference on all possible paths through the code\n— in other words, with a borrowed reference you don’t run the risk of leaking\nwhen a premature exit is taken.  The disadvantage of borrowing over owning is\nthat there are some subtle situations where in seemingly correct code a borrowed\nreference can be used after the owner from which it was borrowed has in fact\ndisposed of it..A borrowed reference can be changed into an owned reference by calling\n..  This does not affect the status of the owner from which the\nreference was borrowed — it creates a new owned reference, and gives full\nowner responsibilities (the new owner must dispose of the reference properly, as\nwell as the previous owner)..Whenever an object reference is passed into or out of a function, it is part of\nthe function’s interface specification whether ownership is transferred with the\nreference or not..Most functions that return a reference to an object pass on ownership with the\nreference.  In particular, all functions whose function it is to create a new\nobject, such as . and ., pass\nownership to the receiver.  Even if the object is not actually new, you still\nreceive ownership of a new reference to that object.  For instance,\n. maintains a cache of popular values and can return a\nreference to a cached item..Many functions that extract objects from other objects also transfer ownership\nwith the reference, for instance ..  The picture\nis less clear, here, however, since a few common routines are exceptions:\n., ., ., and\n. all return references that you borrow from the\ntuple, list or dictionary..The function . also returns a borrowed reference, even\nthough it may actually create the object it returns: this is possible because an\nowned reference to the object is stored in ...When you pass an object reference into another function, in general, the\nfunction borrows the reference from you — if it needs to store it, it will use\n. to become an independent owner.  There are exactly two\nimportant exceptions to this rule: . and\n..  These functions take over ownership of the item passed\nto them — even if they fail!  (Note that . and friends\ndon’t take over ownership — they are “normal.”).When a C function is called from Python, it borrows references to its arguments\nfrom the caller.  The caller owns a reference to the object, so the borrowed\nreference’s lifetime is guaranteed until the function returns.  Only when such a\nborrowed reference must be stored or passed on, it must be turned into an owned\nreference by calling ...The object reference returned from a C function that is called from Python must\nbe an owned reference — ownership is transferred from the function to its\ncaller..There are a few situations where seemingly harmless use of a borrowed reference\ncan lead to problems.  These all have to do with implicit invocations of the\ninterpreter, which can cause the owner of a reference to dispose of it..The first and most important case to know about is using . on\nan unrelated object while borrowing a reference to a list item.  For instance:.This function first borrows a reference to ., then replaces\n. with the value ., and finally prints the borrowed reference.\nLooks harmless, right?  But it’s not!.Let’s follow the control flow into ..  The list owns\nreferences to all its items, so when item 1 is replaced, it has to dispose of\nthe original item 1.  Now let’s suppose the original item 1 was an instance of a\nuser-defined class, and let’s further suppose that the class defined a\n. method.  If this class instance has a reference count of 1,\ndisposing of it will call its . method..Since it is written in Python, the . method can execute arbitrary\nPython code.  Could it perhaps do something to invalidate the reference to\n. in .?  You bet!  Assuming that the list passed into\n. is accessible to the . method, it could execute a\nstatement to the effect of ., and assuming this was the last\nreference to that object, it would free the memory associated with it, thereby\ninvalidating ...The solution, once you know the source of the problem, is easy: temporarily\nincrement the reference count.  The correct version of the function reads:.This is a true story.  An older version of Python contained variants of this bug\nand someone spent a considerable amount of time in a C debugger to figure out\nwhy his . methods would fail….The second case of problems with a borrowed reference is a variant involving\nthreads.  Normally, multiple threads in the Python interpreter can’t get in each\nother’s way, because there is a global lock protecting Python’s entire object\nspace.  However, it is possible to temporarily release this lock using the macro\n., and to re-acquire it using\n..  This is common around blocking I/O calls, to\nlet other threads use the processor while waiting for the I/O to complete.\nObviously, the following function has the same problem as the previous one:.In general, functions that take object references as arguments do not expect you\nto pass them . pointers, and will dump core (or cause later core dumps) if\nyou do so.  Functions that return object references generally return . only\nto indicate that an exception occurred.  The reason for not testing for .\narguments is that functions often pass the objects they receive on to other\nfunction — if each function were to test for ., there would be a lot of\nredundant tests and the code would run more slowly..It is better to test for . only at the “source:” when a pointer that may be\n. is received, for example, from . or from a function that\nmay raise an exception..The macros . and . do not check for .\npointers — however, their variants . and .\ndo..The macros for checking for a particular object type (.) don’t\ncheck for . pointers — again, there is much code that calls several of\nthese in a row to test an object against various different expected types, and\nthis would generate redundant tests.  There are no variants with .\nchecking..The C function calling mechanism guarantees that the argument list passed to C\nfunctions (. in the examples) is never . — in fact it guarantees\nthat it is always a tuple ...It is a severe error to ever let a . pointer “escape” to the Python user..It is possible to write extension modules in C++.  Some restrictions apply.  If\nthe main program (the Python interpreter) is compiled and linked by the C\ncompiler, global or static objects with constructors cannot be used.  This is\nnot a problem if the main program is linked by the C++ compiler.  Functions that\nwill be called by the Python interpreter (in particular, module initialization\nfunctions) have to be declared using .. It is unnecessary to\nenclose the Python header files in . — they use this form\nalready if the symbol . is defined (all recent C++ compilers\ndefine this symbol)..Many extension modules just provide new functions and types to be used from\nPython, but sometimes the code in an extension module can be useful for other\nextension modules. For example, an extension module could implement a type\n“collection” which works like lists without order. Just like the standard Python\nlist type has a C API which permits extension modules to create and manipulate\nlists, this new collection type should have a set of C functions for direct\nmanipulation from other extension modules..At first sight this seems easy: just write the functions (without declaring them\n., of course), provide an appropriate header file, and document\nthe C API. And in fact this would work if all extension modules were always\nlinked statically with the Python interpreter. When modules are used as shared\nlibraries, however, the symbols defined in one module may not be visible to\nanother module. The details of visibility depend on the operating system; some\nsystems use one global namespace for the Python interpreter and all extension\nmodules (Windows, for example), whereas others require an explicit list of\nimported symbols at module link time (AIX is one example), or offer a choice of\ndifferent strategies (most Unices). And even if symbols are globally visible,\nthe module whose functions one wishes to call might not have been loaded yet!.Portability therefore requires not to make any assumptions about symbol\nvisibility. This means that all symbols in extension modules should be declared\n., except for the module’s initialization function, in order to\navoid name clashes with other extension modules (as discussed in section\n.). And it means that symbols that . be accessible from\nother extension modules must be exported in a different way..Python provides a special mechanism to pass C-level information (pointers) from\none extension module to another one: Capsules. A Capsule is a Python data type\nwhich stores a pointer (.).  Capsules can only be created and\naccessed via their C API, but they can be passed around like any other Python\nobject. In particular,  they can be assigned to a name in an extension module’s\nnamespace. Other extension modules can then import this module, retrieve the\nvalue of this name, and then retrieve the pointer from the Capsule..There are many ways in which Capsules can be used to export the C API of an\nextension module. Each function could get its own Capsule, or all C API pointers\ncould be stored in an array whose address is published in a Capsule. And the\nvarious tasks of storing and retrieving the pointers can be distributed in\ndifferent ways between the module providing the code and the client modules..Whichever method you choose, it’s important to name your Capsules properly.\nThe function . takes a name parameter\n(.); you’re permitted to pass in a . name, but\nwe strongly encourage you to specify a name.  Properly named Capsules provide\na degree of runtime type-safety; there is no feasible way to tell one unnamed\nCapsule from another..In particular, Capsules used to expose C APIs should be given a name following\nthis convention:.The convenience function . makes it easy to\nload a C API provided via a Capsule, but only if the Capsule’s name\nmatches this convention.  This behavior gives C API users a high degree\nof certainty that the Capsule they load contains the correct C API..The following example demonstrates an approach that puts most of the burden on\nthe writer of the exporting module, which is appropriate for commonly used\nlibrary modules. It stores all C API pointers (just one in the example!) in an\narray of . pointers which becomes the value of a Capsule. The header\nfile corresponding to the module provides a macro that takes care of importing\nthe module and retrieving its C API pointers; client modules only have to call\nthis macro before accessing the C API..The exporting module is a modification of the . module from section\n.. The function . does not call\nthe C library function . directly, but a function\n., which would of course do something more complicated in\nreality (such as adding “spam” to every command). This function\n. is also exported to other extension modules..The function . is a plain C function, declared\n. like everything else:.The function . is modified in a trivial way:.In the beginning of the module, right after the line.two more lines must be added:.The . is used to tell the header file that it is being included in the\nexporting module, not a client module. Finally, the module’s initialization\nfunction must take care of initializing the C API pointer array:.Note that . is declared .; otherwise the pointer\narray would disappear when . terminates!.The bulk of the work is in the header file ., which looks\nlike this:.All that a client module must do in order to have access to the function\n. is to call the function (or rather macro)\n. in its initialization function:.The main disadvantage of this approach is that the file . is\nrather complicated. However, the basic structure is the same for each function\nthat is exported, so it has to be learned only once..Finally it should be mentioned that Capsules offer additional functionality,\nwhich is especially useful for memory allocation and deallocation of the pointer\nstored in a Capsule. The details are described in the Python/C API Reference\nManual in the section . and in the implementation of Capsules (files\n. and . in the Python source\ncode distribution)..Footnotes.An interface for this function already exists in the standard module .\n— it was chosen as a simple and straightforward example..The metaphor of “borrowing” a reference is not completely correct: the owner\nstill has a copy of the reference..Checking that the reference count is at least 1 . — the\nreference count itself could be in freed memory and may thus be reused for\nanother object!.These guarantees don’t hold when you use the “old” style calling convention —\nthis is still found in much existing code.",
        "This manual documents the API used by C and C++ programmers who want to write\nextension modules or embed Python.  It is a companion to .,\nwhich describes the general principles of extension writing but does not\ndocument the API functions in detail.",
        "Find centralized, trusted content and collaborate around the technologies you use most..Q&A for work.Connect and share knowledge within a single location that is structured and easy to search..I noticed in the python doc that there is a . flag. Here is what python doc says:.Execute the Python code in .. . can be one or more\n  statements separated by newlines, with significant leading whitespace\n  as in normal module code..There is no example in the doc and I couldn't figure out how to make this work, and also in what situations it may help..Anyone have any clue?.Just pass regular Python code as the argument to the flag:.Import modules works, and blank lines are OK, too:.When using this feature, just be mindful of shell quoting (and indentation), and keep in mind that if you're using this outside of a few shell scripts, you might be doing it wrong..Easiest example.It is useful whenever your program has a single line of code, for example, list comprehensions, etc. .Another example can be.As you can see, multiple statements are separated by . .\r\n                                                By clicking “Post Your Answer”, you agree to our ., . and .\n.\r\n                        Your privacy\r\n                    .\r\n                        By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our ..\r\n                    ",
        "",
        "",
        "",
        "New book released!.Hi! I just released the alpha version of my new book; Practical Python Projects. \n      Learn more about it .. In 325+ pages, I will teach you how to implement 12 end-to-end projects. \n      You can buy it from ..\n    .An interesting feature offered to developers by the CPython\nimplementation is the ease of interfacing C code to Python..There are three key methods developers use to call C functions from\ntheir python code - ., . and .. Each\nmethod comes with its own merits and demerits..Firstly, why would you want to interface C with Python?.A few common reasons are :.The Python . is probably\nthe easiest way to call C functions from Python. The ctypes module\nprovides C compatible data types and functions to load DLLs so that\ncalls can be made to C shared libraries without having to modify them.\nThe fact that the C side needn’t be touched adds to the simplicity of\nthis method..Simple C code to add two numbers, save it as .Next compile the C file to a . file (DLL in windows) This will\ngenerate an adder.so file..Now in your python code -.And the output is as follows.In this example the C file is self explanatory - it contains two\nfunctions, one to add two integers and another to add two floats..In the python file, first the ctypes module is imported. Then the CDLL\nfunction of the ctypes module is used to load the shared lib file we\ncreated. The functions defined in the C lib are now available to us via\nthe . variable. When . is called, internally a\ncall is made to the . C function. The ctypes interface allows\nus to use native python integers and strings by default while calling\nthe C functions..For other types such as boolean or float, we have to use the correct\nctypes. This is seen while passing parameters to the\n.. We first create the required c_float types from\npython decimal values, and then use them as arguments to the C code.\nThis method is simple and clean, but limited. For example it’s not\npossible to manipulate objects on the C side..Simplified Wrapper and Interface Generator, or SWIG for short is another\nway to interface C code to Python. In this method, the developer must\ndevelop an extra interface file which is an input to SWIG (the command\nline utility)..Python developers generally don’t use this method, because it is in most\ncases unnecessarily complex. This is a great method when you have a\nC/C++ code base, and you want to interface it to many different\nlanguages.. (from the . ).The C code, . that has a variety of functions and variables.The interface file - this will remain the same irrespective of the\nlanguage you want to port your C code to :.And now to compile it.Finally, the Python output.As we can see, SWIG achieves the same result, but requires a slightly\nmore involved effort. But it’s worth it if you are targeting multiple\nlanguages..The . is probably the\nmost widely used method - not for its simplicity but for the fact that\nyou can manipulate python objects in your C code..This method requires your C code to be specifically written for\ninterfacing with Python code. All Python objects are represented as a\nPyObject struct and the . header file provides various\nfunctions to manipulate it. For example if the PyObject is also a\nPyListType (basically a list), then we can use the .\nfunction on the struct to get the length of the list. This is equivalent\nto calling . in python. Most of the basic\nfunctions/opertions that are there for native Python objects are made\navailable in C via the . header..To write a C extension that adds all the elements in a python list. (all elements are numbers).Let’s start with the final interface we’d like to have, here is the\npython file that uses the C extension :.The above looks like any ordinary python file, which imports and uses\nanother python module called .. The only difference is that\nthe addList module is not written in Python at all, but rather in C..Next we’ll have a look at the C code that get’s built into the\n. Python module. This may seem a bit daunting at first, but\nonce you understand the various components that go into writing the C\nfile, it’s pretty straightforward..A step by step explanation :.The function . accepts arguments as a PyObject type struct\n(args is also a tuple type - but since everything in python is an\nobject, we use the generic PyObject notion). The incoming arguments is\nparsed (basically split the tuple into individual elements) by\n.. The first parameter is the argument variable to\nbe parsed. The second argument is a string that tells us how to parse\neach element in the args tuple. The character in the Nth position of the\nstring tells us the type of the Nth element in the args tuple, example -\n‘i’ would mean integer, ‘s’ would mean string and ‘O’ would mean a\nPython object. Next multiple arguments follow, these are where you would\nlike the . function to store all the elements that\nit has parsed. The number of such arguments is equal to the number of\narguments which the module function expects to receive, and positional\nintegrity is maintained. For example if we expected a string, integer\nand a python list in that order, the function signature would be.In this case we only have to extract a list object, and store it in the\nvariable .. We then use the . function on our\nlist object and get the length. This is similar to how you would call\n. in python..Now we loop through the list, get each element using the\n. function. This returns a PyObject*. But\nsince we know that the Python objects are also ., we just\nuse the . function to get the required value. We\ndo this for every element and finally get the sum..The sum is converted to a python object and is returned to the Python\ncode with the help of .. Here the “i” indicates that\nthe value we want to build is a python integer object..Now we build the C module. Save the following code as .and run.This should now build and install the C file into the python module we\ndesire..After all this hard work, we’ll now test if the module works -.And here is the output.So as you can see, we have developed our first successful C Python\nextension using the Python.h API. This method does seem complex at\nfirst, but once you get used to it it can prove to be quite useful..Other ways to interface C code to Python is to use an alternative and\nfaster build of python - .. But Cython is\na slightly different language than the main stream python we see. Hence\nthat method is not covered here.",
        "Python can run one-liners from an operating system command line using option -c:\n",
        "",
        "",
        "\n    Connector/Python supports a C extension that interfaces with the MySQL C client\n    library. For queries that return large result sets, using the C\n    Extension can improve performance compared to a . implementation of the MySQL client/server protocol.\n    ., describes how\n    applications that use the . module\n    can use the C Extension. It is also possible to use the C Extension\n    directly, by importing the .\n    module rather than the . module.\n    See .. For information\n    about installing the C Extension, see\n    ..\n  .\n      The C extension was added in version 2.1.1 and is enabled by\n      default as of 8.0.11. The . option\n      determines whether the Python or C version of this connector is\n      enabled and used.\n    ",
        ": .This chapter contains an . to the many different routes for\nmaking your native code (primarily .) available from Python, a\nprocess commonly referred to .. The goal of this chapter is to\ngive you a flavour of what technologies exist and what their respective\nmerits and shortcomings are, so that you can select the appropriate one\nfor your specific needs. In any case, once you do start wrapping, you\nalmost certainly will want to consult the respective documentation for\nyour selected technique..Chapters contents.This chapter covers the following techniques:.These four techniques are perhaps the most well known ones, of which Cython is\nprobably the most advanced one and the one you should consider using first. The\nothers are also important, if you want to understand the wrapping problem from\ndifferent angles. Having said that, there are other alternatives out there,\nbut having understood the basics of the ones above, you will be in a position\nto evaluate the technique of your choice to see if it fits your needs..The following criteria may be useful when evaluating a technology:.Before you set out, you should consider your use case. When interfacing with\nnative code, there are usually two use-cases that come up:.Each technology is demonstrated by wrapping the . function from\n.. While this is a mostly a trivial example, it should serve us well\nto demonstrate the basics of the wrapping solution. Since each technique also\nincludes some form of Numpy support, this is also demonstrated using an\nexample where the cosine is computed on some kind of array..Last but not least, two small warnings:.The . is the backbone of the\nstandard Python interpreter (a.k.a .). Using this API it is possible to\nwrite Python extension module in C and C++. Obviously, these extension modules\ncan, by virtue of language compatibility, call any function written in C or\nC++..When using the Python-C-API, one usually writes much boilerplate code, first to\nparse the arguments that were given to a function, and later to construct the\nreturn type..Note.The Python-C-Api example here serves mainly for didactic reasons. Many of\nthe other techniques actually depend on this, so it is good to have a\nhigh-level understanding of how it works. In 99% of the use-cases you will\nbe better off, using an alternative technique..Note.Since reference counting bugs are easy to create and hard to track down,\nanyone really needing to use the Python C-API should read the .\nfrom the official python documentation. Additionally, there is a tool by the\nname of .\nwhich can help discover common errors with reference counting..The following C-extension module, make the . function from the standard\nmath library available to Python:.As you can see, there is much boilerplate, both to «massage» the arguments and\nreturn types into place and for the module initialisation. Although some of\nthis is amortised, as the extension grows, the boilerplate required for each\nfunction(s) remains..The standard python build system . supports compiling C-extensions\nfrom a ., which is rather convenient:.This can be compiled:.The file . contains the compiled extension, which we can now load in the IPython interpreter:.Note.In Python 3, the filename for compiled modules includes metadata on the Python\ninterpreter (see .) and is thus\nlonger. The import statement is not affected by this..Now let’s see how robust this is:.Analog to the Python-C-API, Numpy, which is itself implemented as a\nC-extension, comes with the .. This API can be used\nto create and manipulate Numpy arrays from C, when writing a custom\nC-extension. See also: ...Note.If you do ever need to use the Numpy C-API refer to the documentation about\n. and\n...The following example shows how to pass Numpy arrays as arguments to functions\nand how to iterate over Numpy arrays using the (old) Numpy-C-API. It simply\ntakes an array as argument applies the cosine function from the . and\nreturns a resulting new array..To compile this we can use distutils again. However we need to be sure to\ninclude the Numpy headers by using :func:...To convince ourselves if this does actually works, we run the following test\nscript:.And this should result in the following figure:. is a . for Python. It provides C compatible data types, and allows\ncalling functions in DLLs or shared libraries. It can be used to wrap these\nlibraries in pure Python..As advertised, the wrapper code is in pure Python..We may now use this, as before:.As with the previous example, this code is somewhat robust, although the error\nmessage is not quite as helpful, since it does not tell us what the type should be..Numpy contains some support for interfacing with ctypes. In particular there is\nsupport for exporting certain attributes of a Numpy array as ctypes data-types\nand there are functions to convert from C arrays to Numpy arrays and back..For more information, consult the corresponding section in the . and the API documentation for\n.\nand ...For the following example, let’s consider a C function in a library that takes\nan input and an output array, computes the cosine of the input array and\nstores the result in the output array..The library consists of the following header file (although this is not\nstrictly needed for this example, we list it for completeness):.The function implementation resides in the following C source file:.And since the library is pure C, we can’t use . to compile it, but\nmust use a combination of . and .:.We can then compile this (on Linux) into the shared library\n.:.Now we can proceed to wrap this library via ctypes with direct support for\n(certain kinds of) Numpy arrays:.And, as before, we convince ourselves that it worked:., the Simplified Wrapper Interface Generator,\nis a software development tool that connects programs written in C and C++\nwith a variety of high-level programming languages, including Python. The\nimportant thing with SWIG is, that it can autogenerate the wrapper code for you.\nWhile this is an advantage in terms of development time, it can also be a\nburden. The generated file tend to be quite large and may not be too human\nreadable and the multiple levels of indirection which are a result of\nthe wrapping process, may be a bit tricky to understand..Note.The autogenerated C code uses the Python-C-Api..Let’s imagine that our . function lives in a . which has\nbeen written in . and consists of the source file .:.and the header file .:.And our goal is to expose the . to Python. To achieve this with\nSWIG, we must write an . which contains the instructions for SWIG..As you can see, not too much code is needed here. For this simple example it is\nenough to simply include the header file in the interface file, to expose the\nfunction to Python. However, SWIG does allow for more fine grained\ninclusion/exclusion of functions found in header files, check the documentation\nfor details..Generating the compiled wrappers is a two stage process:.We can now load and execute the . as we have done in the previous examples:.Again we test for robustness, and we see that we get a better error message\n(although, strictly speaking in Python there is no . type):.Numpy provides . with the .\nfile. This interface file defines various so-called . which support\nconversion between Numpy arrays and C-Arrays. In the following example we will\ntake a quick look at how such typemaps work in practice..We have the same . function as in the ctypes example:.This is wrapped as . using the following SWIG interface\nfile:.And, as before we can use distutils to wrap this:.As previously, we need to use . to specify the location..And, as before, we convince ourselves that it worked:. is both a Python-like language for writing\nC-extensions and an advanced compiler for this language. The Cython .\nis a superset of Python, which comes with additional constructs that allow you\ncall C functions and annotate variables and class attributes with c types. In\nthis sense one could also call it a ...In addition to the basic use case of wrapping native code, Cython supports an\nadditional use-case, namely interactive optimization. Basically, one starts out\nwith a pure-Python script and incrementally adds Cython types to the bottleneck\ncode to optimize only those code paths that really matter..In this sense it is quite similar to SWIG, since the code can be autogenerated\nbut in a sense it also quite similar to ctypes since the wrapping code can\n(almost) be written in Python..While others solutions that autogenerate code can be quite difficult to debug\n(for example SWIG) Cython comes with an extension to the GNU debugger that\nhelps debug Python, Cython and C code..Note.The autogenerated C code uses the Python-C-Api..The main Cython code for our . is contained in the file\n.:.Note the additional keywords such as . and .. Also the\n. is then pure Python..Again we can use the standard . module, but this time we need some\nadditional pieces from the .:.Compiling this:.And running it:.And, testing a little for robustness, we can see that we get good error messages:.Additionally, it is worth noting that . ships with complete\ndeclarations for the C math library, which simplifies the code above to become:.In this case the . statement is used to import the . function..Cython has support for Numpy via the . file which allows you to add\nthe Numpy array type to your Cython code. I.e. like specifying that variable\n. is of type ., you can specify that variable . is of type\n. with a given .. Also, certain optimizations such as\nbounds checking are supported. Look at the corresponding section in the .. In case you\nwant to pass Numpy arrays as C arrays to your Cython wrapped C functions, there\nis a section about this in the ...In the following example, we will show how to wrap the familiar .\nfunction using Cython..This is wrapped as . using the following Cython code:.And can be compiled using .:.And, as before, we convince ourselves that it worked:.In this section four different techniques for interfacing with native code\nhave been presented. The table below roughly summarizes some of the aspects of\nthe techniques..Of all three presented techniques, Cython is the most modern and advanced. In\nparticular, the ability to optimize code incrementally by adding types to your\nPython code is unique..Since this is a brand new section, the exercises are considered more as\npointers as to what to look at next, so pick the ones that you find more\ninteresting. If you have good ideas for exercises, please let us know!",
        "",
        "In some instances, the performance of Python classes to manage data transfer to\nan overlay may not be sufficient. Usually this would be determined by\nimplementing the driver in Python, and profiling to determine performance..A higher performance library can be developed in a lower level language\n(e.g. C/C++) and optimized for an overlay. The driver functions in the library\ncan be called from Python using CFFI (C Foreign Function Interface)..CFFI provides a simple way to interface with C code from Python. The CFFI\npackage is preinstalled in the PYNQ image. It supports four modes, API and ABI,\neach with “in-line” or “out-of-line compilation”. . ABI (Application\nBinary Interface) compatibility mode allows dynamic loading and running of\nfunctions from executable modules, and API mode allows building of C extension\nmodules..The following example taken from\n. shows the ABI inline\nmode, calling the C function . in from Python.C function prototype:.The C function prototype is passed to ., and can be called using\n...C functions inside a shared library can be called from Python using the C\nForeign Function Interface (CFFI). The shared library can be compiled online\nusing the CFFI from Python, or it can be compiled offline..For more information on CFFI and shared libraries refer to:",
        "\n        This is the practice of Python C extensions.\n      .This is the practice of Python C extensions.  It is Python3 that I am practicing now!.It is a general hello world practice.  One may start from here for the simplest Python C extension example..It is a C extension practice who gets arguments passed from Python.  The heyman function will echo the passed name and the number..It is an adding function which will not only gets arguments passed from Python, but also returns a tuple that is composite of the result and the equation string..It is a cross version example that shows how to port between Python 2 and Python 3..\n      This is the practice of Python C extensions.\n    ",
        "This browser is no longer supported..Upgrade to Microsoft Edge to take advantage of the latest features, security updates, and technical support..Modules that are written in C++ (or C) are commonly used to extend the capabilities of a Python interpreter. They're also used to enable access to low-level operating system capabilities..Modules come in three primary types:.This article walks you through building a C++ extension module for . that computes a hyperbolic tangent and calls it from Python code. The routine is implemented first in Python to demonstrate the relative performance gain of implementing the same routine in C++..The article also demonstrates two ways to make the C++ extension available to Python:.You'll find the completed sample from this walkthrough on GitHub at ...Visual Studio 2017 or later, with the Python Development workload installed. The workload includes the Python native development tools, which bring in the C++ workload and toolsets that are necessary for native extensions..Note.When you install the . workload, Python and the . option are installed by default..For more information about the installation options, see .. If you install Python separately, be sure to select . under . in its installer. This option is required for you to use mixed-mode debugging between your Python code and native code..Create a new Python project in Visual Studio by selecting . > . > .. Search for ., select the . template, enter a name and location, and then select ...In the project's . file, paste the following code. To experience some of the ., try entering the code manually..This code computes a hyperbolic tangent without using the math library, and it's what you'll be accelerating with native extensions..Tip.Write your code in pure Python before you rewrite it in C++. This way, you can more easily check to ensure that your native code is correct..To view the results, run the program by selecting . > . or by selecting Ctrl+F5..You can adjust the . variable to change how long the benchmark takes to run. For the purpose of this walkthrough, set the count so that the benchmark takes about two seconds..Tip.When you run benchmarks, always use . > .. This helps avoid the overhead that you incur when you run the code within the Visual Studio debugger..Follow the instructions in this section to create two identical C++ projects, . and .. Later, you'll use a separate approach in each project to expose the C++ code to Python..In ., right-click the solution,  and then select . > .. A Visual Studio solution can contain both Python and C++ projects, which is one of the advantages of using Visual Studio for Python..Search on ., select ., specify either . for the first project or . for the second project, and then select ...Tip.Alternatively, with the Python native development tools installed in Visual Studio, you can start with the Python Extension Module template. The template has much of what's described here already in place..For this walkthrough, though, starting with an empty project demonstrates building the extension module step by step. After you understand the process, you can use the template to save time when you write your own extensions..To create a C++ file in the new project, right-click the . node, and then select . > ...Select ., name it ., and then select ...Important.A file with the . extension is necessary to turn on the C++ property pages in the steps that follow..On the main toolbar, use the dropdown menu to do either of the following:.In ., right-click the C++ project, select ., and then do the following:.a. For ., enter ...\nb. For ., enter either . or ., depending on your selection in the preceding step..Note.When you create your own projects, you'll want to configure both the . and . configurations. In this unit, you're configuring only the debug configuration and setting it to use a release build of CPython. This configuration disables some debugging features of the C++ runtime, including assertions. Using CPython debug binaries (.) requires different settings..Set the properties as described in the following table:.Note.If the . tab isn't displayed in the project properties, the project contains no files that it identifies as C/C++ source files. This condition can occur if you create a source file without a . or . file extension..For example, if you accidentally entered . instead of . earlier in the new item dialog, Visual Studio creates the file but doesn't set the file type to ., which activates the C/C++ properties tab. Such misidentification remains even if you rename the file with a . file extension..To set the file type properly, in ., right-click the file and select .. Then, for ., select ...Select ...To test your configurations (both . and .), right-click the C++ project, and then select ...You'll find the . files in the . folder, under . and ., not in the C++ project folder itself..In the C++ project's . file, add the following code:.Build the C++ project again to confirm that your code is correct..If you haven't already done so, repeat the preceding steps to create a second project named . with an identical configuration..To make the C++ DLL an extension for Python, you first modify the exported methods to interact with Python types. You then add a function that exports the module, along with definitions of the module's methods..The sections that follow explain how you perform these steps by using both the CPython extensions and PyBind11..For more background on the code shown in this section, see the . and, especially, the . page. Be sure to select your version of Python in the dropdown list at the upper right..At the top of the . file, include .:.Modify the . method to accept and return Python types (that is, a .):.Add a structure that defines how the C++ . function is presented to Python:.Add a structure that defines the module as you want to refer to it in your Python code, specifically when you use the . statement..The name that's being imported in this code should match the value in the project properties under . > . > ...In the following example, the . module name means that you can use . in Python, because . is defined within .. File names that are internal to the C++ project, such as ., are inconsequential..Add a method that Python calls when it loads the module, which must be named ., where . exactly matches the C++ project's . > . property. That is, it matches the file name of the . file that's built by the project..Build the C++ project again to verify your code. If you encounter errors, see the . section..If you completed the steps in the previous section, you certainly noticed that you used lots of boilerplate code to create the necessary module structures for the C++ code. PyBind11 simplifies the process through macros in a C++ header file that accomplish the same result, but with much less code..For more information about the code in this section, see ...Install PyBind11 by using pip: . or ...Alternatively, you can install PyBind11 by using the Python Environments window, and then use its . command for the next step..In the same terminal, run . or ...This prints a list of paths that you should add to your project's . > . > . property. Be sure to remove the . prefix, if it's present..At the top of a fresh . that doesn't include any of the changes from the previous section, include .:.At the bottom of ., use the . macro to define the entry point to the C++ function:.Build the C++ project to verify your code. If you encounter errors, see the next section, \"Troubleshoot compiling failures,\" for solutions..The C++ module might fail to compile for the following reasons:.Error: Unable to locate . (. and/or .).Solution: Verify that the path in . > . > . in the project properties points to your Python installation's . folder. See step 6 under ...Error: Unable to locate Python libraries.Solution: Verify that the path in . > . > . in the project properties points to your Python installation's . folder. See step 6 under ...Linker errors related to target architecture.Solution: Change the C++ target's project architecture to match that of your Python installation. For example, if you're targeting Win32 with the C++ project but your Python installation is 64-bit, change the C++ project to x64..Now that you have the DLLs structured as Python extensions, you can refer to them from the Python project, import the modules, and use their methods..You can make the DLL available to Python in any of several ways. Here are two approaches to consider:.This first method works if the Python project and the C++ project are in the same solution. Do the following:.In ., right-click the . node in your Python project, and then select ...In the dialog that appears, select the . tab, select both the . and . projects, and then select ...An alternative method installs the module in your Python environment, which makes the module available to other Python projects as well. For more information, see the .. Do the following:.Create a file named . in the C++ project by right-clicking the project and selecting . > ...Select ., name the file ., and then select ...Naming the file with the . extension makes Visual Studio recognize it as a Python file despite the use of the C++ file template..When the file appears in the editor, paste the following code into it, as appropriate to the extension method:.:.:.Create a second file named . in the C++ project, and paste the following code into it:.To build the extension, right-click the open . tab, and then select .. You'll delete the . name from the path before you use it..In ., right-click the active Python environment, and then select ...Tip.If you've already installed the package, you'll see it listed here. Before you continue, click the . to uninstall it..In the search box, paste the copied path, delete . from the end, and then select Enter to install the module from that directory..Tip.If the installation fails because of a permission error, add . to the end, and try the command again..After you've made the DLL available to Python, as described in the preceding section, you can call the . and . functions from Python code and compare their performance to the Python implementation. To call the DLL, do the following:.Add the following lines in your . file to call the methods that were exported from the DLLs and display their outputs:.Run the Python program by selecting . > . or by selecting Ctrl+F5..Note.If the . command is disabled, in ., right-click the Python project, and then select ...Observe that the C++ routines run approximately five to twenty times faster than the Python implementation. Typical output appears as follows:.Try increasing the . variable so that the differences are more pronounced..A . build of the C++ module also runs slower than a . build, because the debug build is less optimized and contains various error checks. Feel free to switch between those configurations for comparison, but remember to go back and update the properties that you set earlier for the release configuration..In the output, you might see that the PyBind11 extension isn't as fast as the CPython extension, though it should be significantly faster than the pure Python implementation. This difference is largely because you used the . call, which doesn't support multiple parameters, parameter names, or keywords arguments. PyBind11 generates slightly more complex code to provide a more Python-like interface to callers. But, because the test code calls the function 500,000 times, the results might greatly amplify that overhead!.You could reduce the overhead further by moving the . loop into the native code. This approach would involve using the . (or the PyBind11 . type for .) to process each element. Removing the repeated transitions between Python and C++ is an effective way to reduce the time it takes to process the sequence..If you receive an . message when you try to import your module, you can resolve it in one of the following ways:.When you're building through a project reference, ensure that your C++ project properties match the Python environment that's activated for your Python project, especially the . and . directories..Ensure that your output file is named .. Any other name or extension will prevent it from being imported..If you installed your module by using the . file, check to ensure that you ran the . command in the Python environment that's activated for your Python project. Expanding the Python environment in Solution Explorer should display an entry for ...Visual Studio supports debugging Python and C++ code together. In this section, you walk through the process by using the . project. The process is the same for the . project..In ., right-click the Python project, select ., select the . tab, and then select the . > . option..Tip.When you enable native code debugging, the Python output window might close immediately after the program has finished without giving you the usual . pause..Solution: To force a pause after you've enabled native code debugging, add the . option to the . > . field on the . tab. This argument puts the Python interpreter into interactive mode after the code has run, at which point it waits for you to select Ctrl+Z and then Enter to close the window..Alternatively, if you don't mind modifying your Python code, you can add . and . statements at the end of your program. This code duplicates the original pause prompt..Select . > . to save the property changes..On the Visual Studio toolbar, set the build configuration to ...Because code generally takes longer to run in the debugger, you might want to change the . variable in your . file to a value that's about five times smaller than the default value. For example, change it from . to ...In your C++ code, set a breakpoint on the first line of the . method, and then start the debugger by selecting . or . > ...The debugger stops when the breakpoint code is called. If the breakpoint isn't hit, check to ensure that the configuration is set to . and that you've saved the project, which doesn't happen automatically when you start the debugger..At the breakpoint, you can step through the C++ code, examine variables, and so on. For more information about these features, see ...You can create Python extensions in a variety of ways, as described in the following table. The first two rows, . and ., are discussed in this article..You'll find the completed sample from this walkthrough on GitHub at ...Feedback will be sent to Microsoft: By pressing the submit button, your feedback will be used to improve Microsoft products and services. .Thank you..Submit and view feedback for.Feedback will be sent to Microsoft: By pressing the submit button, your feedback will be used to improve Microsoft products and services. .Thank you.",
        "",
        "            Article\n      .Many popular . modules are written in the . language, and bugs in C extensions can cause nasty crashes that Python's error-catching mechanism won't catch. Fortunately, numerous powerful debuggers—notably, the . (GDB)—were designed for the C language. In Python 3.9, developers can use these to debug Python programs, and particularly the C extensions included in Python programs..This article shows how to use the improved Python debug build in Python 3.9. I'll first discuss how we adapted Python to allow developers to use traditional C debuggers, then show you how to use the debug build and GDB to debug C extensions in a Python program..Python 3.9 is now provided in the . 8.4 AppStream. The command to install the new version is:.Python 3.9 brings many new features:.See . for the full list of changes..When a Python executable is highly optimized, such as the one shipped in RHEL, a typical C debugger doesn't work well. The debugger can't read many helpful pieces of information, such as function arguments, type information, and local variables..Python does have a built-in fault-handler module that prints the Python\ntraceback when a crash occurs. But when a Python object is corrupted (by a buffer overflow or for any other reason), the executable can continue for a long time before crashing. In this case, knowing the crash location is useless. Usually, the crash\noccurs during a garbage collection, when Python visits all Python objects.\nIt's therefore hard to guess how the object was corrupted..Unfortunately, for various reasons, some bugs can be reproduced only\non production systems, not on developers' workstations. This adds to the importance of a good debugger..Python can be built in debug mode, which adds many runtime checks. It\nhelps to detect bugs such as corrupted Python objects. Prior to Python 3.9, a major usability issue was the need to rebuild C extensions in debug mode so they could run with a debug build of Python..I have been working for three years on the Python debugging experience to make it easier\nto use a C-language debugger such as GDB on Python. This section discusses the changes to Python that were required..The first practical issue was that C extensions needed to be rebuilt\nin debug mode to be able to use a Python debug build..I made the Python debug build compatible at an application binary interface (ABI) level with the Python release build in ..\nThe main . C structure is now the same in release and debug builds..The debug build no longer defines the . macro, which caused\nthe ABI incompatibility. If you want the macro, you need to explicitly request it through the . build option. See the\n. for more details..Another issue was that C extensions were linked to libpython. When\na C extension was built in release mode and imported into a Python executable that was built in debug mode, the extension pulled in a version of libpython built in release mode, which was incompatible..Python functions such as . are already loaded in the\nrunning Python process. C extensions inherit these symbols when their\ndynamic libraries are loaded. Therefore, linking C extensions to libpython explicitly\nis not strictly required..I modified how C extensions are built in Python 3.8 so the extensions are no longer\nlinked to libpython: See ..\nSome RHEL packages contained C extensions that linked to libpython\nmanually; these had to be modified further..Last but not least, the Python package was modified to build Python in\ndebug mode with . rather than .. The . option is meant to allow\nsome optimizations that don't interfere with debug information. In practice, GDB is\nfully usable only on an executable built with ., which disables all\ncompiler optimizations..The Python 3.9 debug build shipped with RHEL 8.4 combines all of these\nenhancements and is now usable with debuggers. A Python 3.9 executable built in debug mode can import C extensions built in release mode. In short, the . executable can be used as a seamless drop-in replacement for the usual . to help you run a debug session..A special debug build of Python can work with a C debugger pretty much like a C program. This section shows how to use GDB to debug a Python program, plus some special debugger commands Python provides..Before showing how debugging works better with the new Python 3.9 debug build, let's start with the release build, which is not usable with GDB..First, install GDB and the Python 3.9 debug symbols:.Create a simple Python program named . to play with GDB:.Debug . in GDB and interrupt it with .+.:.If you try to explore the problem, you find that GDB fails to read the function arguments in .:.GDB also fails to read . local variables:.In the previous output, GDB displays\n., rather than expected values. Usually, this means that CPU registers are used for these values. Since CPU registers are used for multiple purposes, GDB cannot guess whether the register currently contains the specified function argument or variable or something else..In addition, the . executable is built in release mode with link time\noptimization (LTO), profile guided optimization (PGO), and .\noptimizations. Because of these optimizations, when debugged functions get inlined by the compiler, GDB's . command can display invalid call stacks..Now install the new Python 3.9 debug build:.These commands enable the . module, install the .\npackage from this module, and then install debug symbols. The . repository is enabled in these commands to get the . module..Now, run GDB again to debug the same . program, but using\n.. Again, interrupt the program with .+.:.Reading the . function arguments now gives the expected values:.Reading . local variables now also gives the\nexpected values:.As you can see, the . messages are gone. GDB works as expected thanks to the new executable built without compiler optimizations..Python comes with a . gdb extension\n(implemented in Python) that adds GDB commands prefixed by .. Expanding this prefix with the tab key shows the available commands:.The . command displays the Python call stack:.The . command lists Python local variables:.The . command gets the value of a Python\nvariable:.Before the program even runs its first statement, a debug build of Python can detect potential problems. When Python is built in debug mode, many debug checks are executed at\nruntime to detect bugs in C extensions. For example:.See the . web page for more details..Red Hat contributed the following changes to Python upstream to enhance the Python debug build:.Python now works quite well with powerful open source debuggers such as GDB. We suggest you try out a Python debug build and GDB when you encounter a problem, especially a segmentation fault caused by a C extension to Python.",
        "This tutorial was built using Python 3.6. The official documentation can be\nfound here:\n.In this tutorial we are going to take a look at how you can create a really\nsimple Python module using the . programming language. I felt this was a good\ntopic to cover as I personally struggled with finding succinct documentation\nthat worked and showed me the basics..Being able to write . extensions can come in handy in scenarios where the\nPython language becomes a bottleneck. Sometimes you require the raw performance\nof a low-level language like . in order to reduce things like response times\nand processing times..In this tutorial we’ll be building a very simple . based Python module that\nwill feature a number of different functions that should hopefully give you\nenough to get started..We’ll be creating 2 distinct functions:.Let’s dive into the . code. Open up the . file that will contain your new\nmodule and add . to the top. This will bring in the\nnecessary . Python objects that will allow us to construct our module..Thankfully Python includes some modules that make extending the language easier.\nHere we can specify the name of our module and pass in the necessay . files\nthat make up our module..In order to . and . our newly created . module we have to do the\nfollowing:.When run in succession you should see the following output. We can then start\nour Python interpreter and call our newly created module:.Let’s now take a look at a more complex function that will take in a value .\nand then return the appropriate fibonacci number. We aren’t going to do any\nfancy . here, it’s going to be a plain old recursive function that\nfeatures terrible performance. However it will show us how to both take in a\nvalue and return a value in our . module..Again we should build and install this like we have done before. We can then\ntest this out like so:.Hopefully you found this tutorial useful and it clarifies the process of\ncreating your own . based modules. If you feel like leaving some feedback or\nasking some further questions then please feel free to in the comments section\nbelow.",
        "",
        "Code Review Stack Exchange is a question and answer site for peer programmer code reviews. It only takes a minute to sign up..Q&A for work.Connect and share knowledge within a single location that is structured and easy to search..I want to use . to remove wheel files from the . directory in my project. (*).Actually, I use the following command:.Is there a shorter/cleaner way to do that?.(*) the setuptools command . doesn't work for me..If you need to use python for being crossplattform and if you need to do this in one line then this is the way to go, yes..For some reason.Alternatives to consider:.I would have expected that a one-line for loop would work, but it doesn't seem to in . when there is a command before it..I think there is no much cleaner solution.\r\n                                                By clicking “Post Your Answer”, you agree to our ., . and .\n.\r\n                        Your privacy\r\n                    .\r\n                        By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our ..\r\n                    ",
        "C API functions are used in PSS®E modules for Python 2.7. After the Python 3 update, some code written in Python 2 are incompatible with the new Python 3 environment. However, Siemens PTI intends to support either version of Python. Some codes have to modify or rewrite. This project focuses these updates and tests..There is already a list of solutions. But those untested codes are not 100% reliable. There are total 10 Python C APIs. We have to:.We have to write up a document describing each function in each module and what it is supposed to do. Also, we have to add descriptions as doc strings to each function and verify that they can be seen correctly through the help function. In the end, we need to write a brief summary of why the test coverage is complete.. Microsoft Visual Studio 2008, Python 3.2, Python 2.7. 3 Weeks.All ten C API functions are sufficiently demonstrated and tested. Required descriptions, documents, and summary are finished and handed to the manager..I was not familiar with C language. But this project required some programming in C. So, during this project, I learned a lot of knowledge in C programming language, memory related stuff, and pointer, including PyObject, DECREF, Malloc, etc..Also, my programming skill in Python improved because we needed to test the API, which required Python programming.",
        "Get . now with O’Reilly .O’Reilly members experience live online training, plus books, videos, and digital content from .You have a Python\n.class and want to recode it as a C extension\nfor speed while keeping all client-code unchanged, so it must remain\na class.\n.One hardly ever sees Python class objects built in C extensions. And\nyet it’s anything but difficult, and, in fact,\nit’s quite handy:\n.This recipe shows how to define a new Python class from a C extension\nmodule. The class’s methods are implemented in C,\nbut the class can still be instantiated, extended, and subclassed\nfrom Python. The same technique can also be used with inheritance to\nextend an existing Python class with methods written in C. In this\nrecipe, the first argument to\n.\nis passed as ., indicating that the new class\nhas no base classes. Pass the tuple of base classes in this spot, and\nyou’ll get normal Python inheritance behavior, even\nthough your new class is being built in a C extension rather than in\nPython source code.\n.The usual method of creating new types in an extension module is to\ndefine a new instance of . and provide\ncallbacks to the various C functions that implement the type.\nHowever, it may be better to define the new type as a Python class,\nso that the type can be instantiated and subclassed from Python. In\nsome cases, when defining a custom exception type, for example, it is\nrequired that the new type be a Python class.\n.The methods in this recipe are coded as C functions and are described\nby a table of\n. statements in the same way that a\nmodule’s methods (functions) are described. The key\nfact that allows these functions to become unbound methods is that\neach of them is first wrapped in a\n.\nobject and then in a\n.\nobject. The . turns the C function into\na Python object, and the . associates the\nfunction with a particular class as an unbound method. Finally, the\nmethods are added to the class’s dictionary, which\nmakes them callable on instances of the class.\n.Note that base classes can be specified for the new class by passing\na tuple of class objects as the first argument to\n.. These can be existing Python classes.\nThe second argument passed to .\nbecomes the . argument passed to the C\nfunction. This can be any Python object, but it’s\nnot very useful in most cases since you can just as easily keep a\nstatic C variable. However, it can be very handy when you want to use\nthe same C function, associated with different data, to implement\nmore than one Python function or method. Also note that the class\ninstance is passed to the C functions as the first argument in the\n. tuple.\n.The . manual is available\nas part of the standard Python documentation set at .;\ndocumentation on the Python C API at ...\n.Get . now with O’Reilly .O’Reilly members experience live online training, plus books, videos, and digital content from ",
        "I'm going through a book on python and the author starts python in one of his examples by typing \"python -c\" in the command line and I have no idea what that is called or what it means or what other possibilities there are for this so I was hoping someone could point me in a direction containing some info about this..Try writing in the terminal.. and .Just like Daimon said, run . in the terminal for help on all the commands. I'll attach them in full in the lower comment, so people can minimize it..Maybe you should get another reference for the command line?.Some sort of manual, or just a single page that was a manual..Members.Online",
        "",
        "",
        "",
        "\r\n    Explore your training options in 10 minutes\r\n    .\n.When comparing two programming languages—even two of the most popular ones—it’s not always easy to make a one to one comparison. The languages may be so dissimilar or used for such different purposes that it’s hard to match them against each other. Python and C, while having some similarities, are very different languages used for a wide range of software development tasks. .If you’re wondering which language to start with, that’s going to depend on what you’d like to do with your programming. Let’s take a close look at both languages to see what they are capable of. But first….In some ways, C is the great-grandfather of all computer technology in use today. It was first developed in 1972 by Dennis Ritchie at Bell Labs. Its origins were entangled with the development of the UNIX operating system (in fact, UNIX is partly written in C). C is a statically typed, procedural language. There’s a bit of C in just about all the technology we use today. Part of the kernels for Windows and OSX are written in C. .Python was first released to the world in 1991. It was created by Guido van Rossum to be more easily readable than other languages at the time; allowing programmers to do what they need to with fewer lines of code. Python code is high level, dynamically typed, and multi-paradigm. It’s used by a wide range of companies in some very popular applications including Netflix, Pinterest, Spotify, and Instagram..Computer languages are classified as high or low level. This refers to how close they are to speaking directly with the computer in ones and zeroes. The closer a language is to this—the ‘lower levels’ of the machine—the more it’s considered a low-level language. Anything that is closer to human communication and syntax is higher level. Python was designed to be a bit more human readable than most languages, making it a higher level than C. .C is a compiled language while Python is interpreted. This means C is compiled directly to machine code—the lowest level of interaction with the computer that can then be performed by the CPU.  Python has to go through some extra steps of interpretation before it can be used by the computer. This is due to its higher level status. .There’s a lot under the hood that Python will take care of for you automatically. One example of these built in functions is garbage collection. When you program, you create variables, data, all sorts of things that take up (usually) a tiny bit of memory. It’s very easy to do this repeatedly without much thought, but after a while, that memory use can slow things down. The garbage collector handles memory management so that you have that data when you need it, and when you’re done with it, it gets deleted. .81% of participants stated they felt more confident about their tech job prospects after attending a bootcamp. Get matched to a bootcamp today..The average bootcamp grad spent less than six months in career transition, from starting a bootcamp to finding their first job..Python has automatic garbage collection that you don’t have to worry about, whereas C has explicit garbage collection that you have to manage yourself. Why would you want this? There are advantages to having that control over a program’s operations at this level, especially as you get into more sophisticated coding (and this can aid your code’s speed. More on that below). This is just one example, but it illustrates a crucial difference in the philosophies of both languages: Python keeps it out of sight for you, while C gives you full access..Let’s take a look at one clear, apples to apples, comparison. Below is the code used by Python to perform that classic first programming task: it prints the words “Hello world” on the screen:.Now take a look at the same task as written in C:.Clearly it must be easier to get up and running with Python over C: in one you just issue the command to print a line, while the other requires bringing in a library, declaring a thread, and making sure you return an empty value. But does that necessarily make it an easier language? Yes and no. If your immediate goal is to get some text printed on the screen, then yes, Python is going to make much more intuitive sense for someone coding for the first time. C requires you to do a lot of mechanical work just to have the text display..It’s a bit of an oversimplification, but imagine both languages are Lego sets. Think of Python as having a number of great prefabricated, custom parts that look just like the thing they represent. In this metaphor, C is a collection of tons of very small pieces that you can assemble into virtually anything, but obviously they’ll take more time. Which one is easier to work with? It depends on what you want to do..There’s no contest here: C is generally going to be faster than Python. Obviously, this is very dependent on the conditions involved for such a comparison, but as far as comparing basic processing tasks, C is going to win. Why? The short answer is because Python is an interpreted language. Every action in the code needs to be interpreted by the main CPU to perform what’s required. .Python is run on what’s called a virtual machine. This is the process that does the bytecode interpretation to make what you’ve written into something that can be read at the machine level. C is a compiled language, which means that the code gets translated into machine code before running instead of at runtime like Python. C skips the extra step of interpretation that Python programs have to run significantly faster..C also allows for manipulation of the code on such a small level that the programmer can closely fine-tune the performance of it. It’s not uncommon to do bitwise manipulation of data in a program. Just like the name sounds, this is working directly with the ones and zeros. A skilled developer can make their C code very efficient. .Like any of these comparisons, context is everything. If you’re interested in writing code for hardware or embedded machines, C is going to be the way to go. . the difference running both on a .and C is the clear winner. .So if it’s so fast, why bother with Python at all? As discussed earlier, Python is much quicker for getting code up and running. The fact is that you might not be doing heavy number-crunching all the time in the work you do. The measure of speed that’s useful to you may be that human factor. If so, then Python is going to be faster. So context and where you need that speed are both important in these comparisons.. behind Java and C in one study. It is believed that, within three or four years, it will overtake those two languages to be the most popular. C and Python are both in high demand by employers. .As stated earlier, C is found in nearly every piece of computer technology used today. However, that doesn’t necessarily mean writing in C is a major part of a developer’s day. Python is in use by a number of major companies, such as .. Python is also one of the leading languages in use for data science applications, especially machine learning and AI..There’s no question that Python is going to be an easier entry into the world of programming if you’re new to it. Its higher-level status means a lot of the work involved is kept under the hood. This doesn’t mean C is completely unapproachable to the newbie, though. But in terms of writing scripts and applications, especially if you’re brand new to coding, Python is going to be a more gentle and less frustrating introduction. .While C has a steeper learning curve than Python, the process of learning it can get you up to speed on a number of computer science concepts faster than learning other languages. You could spend years with other languages and not have to deal with concepts like algorithm efficiency, for example. That can be fine depending on the work you want to be doing: some developers can make a career doing excellent work without ever getting into those hardcore computer science concepts. .C also has the advantage of being a great introduction to other programming languages. Once you’ve had some experience with C, learning other lower-level languages is that much easier. As . put it: “C has become something of the . of programming. C is a great language for expressing common ideas in programming in a way that most people are comfortable with. Moreover, a lot of the principles used in C…will show up in a lot of other languages you learn so you’ll be able to talk to people, even if they don’t know C, in a way that’s common to both of you.”.Whichever language you decide to pursue, you’ll be learning a valuable skill that is robust, very in demand in the job market, and will keep you challenged for a long time. A good coding bootcamp will have both C and Python classes available. .Career Karma is a platform designed to help job seekers find, research, and connect with job training programs to advance their careers. .. .\n\t\t\tChris is a writer based in metro Detroit. Before writing full-time he was a project manager and developer for the University of Michigan and Detroit Labs, a mobile app start-up. He is a product of a coding bootcamp and avidly supports their mission.\t\t.\n. .Your email address will not be published. Required fields are marked *.\n.\n.\n.\n.Start your career transition today with help from a coding bootcamp..\n        Find a top-rated training program\n        .\n.\n    Find a top-rated training program\n    .\n",
        "\n\t\t\t\t\t\t\tA not-for-profit organization, IEEE is the world's largest technical professional organization dedicated to advancing technology for the benefit of humanity..© Copyright 2021 IEEE - All rights reserved. Use of this web site signifies your agreement to the terms and conditions.\n\t\t\t\t\t\t",
        "",
        "",
        "",
        "Writing your own C extensions to Python can seem like a pretty daunting task\nwhen you first get started. If you take a look at the . the details of reference counting and compilation are enough to\nmake you go crazy. This is the main reason why . .\n. exist for wrapping or compiling C code into Python without\never directly interacting with the API. That being said, I often find that\nall that I need to do is wrap a . C function that accepts a few\ndoubles and returns another double. In this case, it seems crazy to generate\nthe thousands of lines of C code required by automatic methods like Cython\nand SWIG. You might argue that these aesthetic issues don’t provide\nsufficient reason for diving into the rabbit hole that the C API seems to\nbe—and maybe you’d be right—but I’m a stubborn coder and I don’t mind\ngetting my hands a little dirty so I went for it. This was a few years ago\nand since then, I’ve developed a template module that suits my needs\nperfectly and it seems to make the extension writing process relatively\npainless so I thought that I’d share what I’ve learned here..I’m not going to claim that what I say here is a general introduction to\nwriting C extensions because I don’t feel qualified to do that but it\nshould be a sufficient tutorial for a scientific programmer (read: grad\nstudent) to get started and write a fully functional module for their\nresearch. In particular, this tutorial will be most useful for someone\nwho already has a chunk of code written in C and just wants to be able to\ncall a few of those functions directly from within Python. Several people\nhave specifically asked me about how to do this when they have legacy\ndata analysis code that they would like to use with my Markov chain\nMonte Carlo package .. In that context,\nthe C code is expected to return the likelihood of some data given some\nmodel parameters passed as doubles to the C function. This is the same\nformat that would be needed if you just wanted to find the minimum\nchi-squared (or maximum likelihood) solution to a problem using something\nlike\n...To be concrete, let’s consider a specific example: fitting a line\n(parameterized by a slope . and y intercept .) to some . noisy data\npoints \\( \\{ x_n, y_n, \\sigma_n \\} \\). In this case, the\nchi-squared function is given by:.$$\n\\chi^2 (m, b) = \\sum_{n = 1} ^N \\frac{[y_n -\n(m , x_n + b)]^2}{\\sigma_n^2} \\quad .\n$$.It’s probably overkill to write this function in C but it’ll do for our\npurposes today. In C, the file . containing our function should look\nsomething like:.And the corresponding header file . is simply:.Now, our goal is to wrap this function so that we can call it from directly\nwithin Python..The code needed to write the wrapper module is another C file containing\na few special Python functions. Conventionally, the names of C extensions\nbegin with an underscore so let’s call our module . and write it in\na file . (not to be confused with the . file that we wrote\njust a minute ago)..In order to be able to access the C functions and types in the Python API,\nthe first thing that we need to do is import the Python header. I also\nexpect that we’ll want to interact with . arrays and our .\nfunction as well so let’s import those headers too:.Next, we should write the\n. for our module and\nthe function that we’re wrapping:.and declare the function:.This is the first time that we’re seeing anything Python-specific. The\ntype . refers to all Python types. Any communication between the\nPython interpreter and your C code will be done by passing .s so\nany function that you want to be able to call from Python must return one.\nUnder the hood, . is just a . with a reference count and a\npointer to the data contained within the object. This can be as simple as\na . or . or as complicated as a fully functional Python class..The name that I’ve given to the function (.) is also a matter of\nconvention. From Python, we’re going to call the function with the command\n. where . is the name of the module and . is the name\nof the function. Since C doesn’t have any concept of namespaces, the\nconvention is to name your C functions with the form\n. and my preference is to leave out the\nleading underscore but it doesn’t really matter either way..The arguments for the function are pretty standard fare. In our case the\n. object points to the module and the . object is a Python tuple\nof input arguments—we’ll see how to parse them soon. It is also possible\nto accept keyword arguments by including a third . in the calling\nspecification but let’s not get into that here..Now, we’ll specify what the members of this module will be. In this case\nthere is only going to be one function (called .) so the “method\ndefinition” looks like:.More functions can be added by adding more lines like the second one. This\nsecond line contains all the info that the interpreter needs to link a Python\ncall to the correct C function and call it in the right way. The\nfirst string is the name of the function as it will be called from Python,\nthe second object is the C function to link to and the last argument is the\ndocstring for the function. The third argument . means that the\nfunction only accepts positional arguments. If you wanted to support\nkeyword arguments, you would need to change this to ...The final step in initializing your new C module is to write an .\nfunction. This function . be called . where . is\n(of course) the name of the module..Everything that’s going on here should be fairly self explanatory by this\npoint but it’s important to note that if you want to use any of the\nfunctionality defined by ., you need to include the call to\n. (a function defined in the . header)..Up to this point, we’ve written only about 25 lines of C code to set up\na C extension module. All of these steps will be common between any modules\nthat you write but as we continue, the details become somewhat less general\nbecause I will focus on building a wrapper for scientific code..Now, it’s time to write the . function that we declared above.\nIn this example, the . tuple will contain two .s (the slope\nand y-intercept of our model) and three . arrays for the ., .\nand uncertainties that constitute the “data” that we’re trying to model.\nLet’s just throw down the whole function here and then dissect it line-by-line\nbelow:.I know that that was a lot in one go so let’s break things down a little bit.\nThe first thing that we did was parse the input tuple using the\n. function. This function takes the tuple, a format and\nthe list of pointers to the objects that you want to take the input values.\nThis format should be familiar if you’ve ever used something like the\n. function in C but the format characters are .. In our example, .\nindicates that the argument should be cast as a C . and . is\njust a catchall for .s. There isn’t a specific format character\nfor . arrays so we have to parse them as raw .s and then\ninterpret them afterwards. If . fails, it will return\n. which is the C-API technique for propagating exceptions. That means\nthat we should also return . immediately if parsing the tuple fails..The next few lines (12-25) show how to load . arrays from the raw\nobjects. The\n.\nfunction is a fairly general method for converting an arbitrary Python\nobject into a well-behaved . array that can be used in a standard\nC function. It is important to note that this creation mechanism only\nreturns a copy of the object if necessary. Instead, the function normally\nonly returns a pointer to the input object if it was already a .\narray satisfying various requirements that we won’t discuss in detail here.\nThe flags . and . ensure that the returned array\nobject will be represented as contiguous arrays of C .s. There are\nsome other options available for different types, orderings and permissions\nbut most of the time, this is probably what you’ll need and the other\noptions are described in ...: Memory management in Python works by keeping\ntrack of the number of “references” to a particular object and then\ndeallocating the memory of that object when that count reaches zero.\nYou can read more about the details of this system\n.\nbut for now, you need to keep in mind that when you return a .\nfrom a function you might want to run . on it to\nincrement the reference count and when you create a new object within\nyou function that you don’t want to return, you should run . on\nit before the function returns (even if the execution failed) so that you\ndon’t end up with a memory leak. The .\nmakes the important comment that it is part of each function’s “interface\nspecification” whether or not it increases the reference count of an\nobject before it returns or not. With this in mind, you need to keep\ncareful track of which functions do what or the memory usage can become\na little ugly..In our example, the objects returned by . do not have\ntheir reference count incremented (the calling function still “owns” them)\nso you don’t need to decrement the reference count of the . objects\nbefore returning. Conversely, . does return an object with\na +1 reference count. This means that you . call . with\nthe . objects as the first argument before returning from this\nfunction. If . can’t coerce the input object into a\nform digestible as a . array, it will return . so that’s why\non lines 19-21, I actually use .. . checks\nto make sure that the object isn’t a . pointer before trying to\ndecrease the reference count whereas .\nwill explode if you try to call it on ...If we successfully reach line 25 then all of the input arguments were\nas expected and we have the input . arrays arranged the way we want\nthem to be. Now we can get on to the fun stuff. For simplicity,\non line 26, I’m assuming that we received a 1D array (but I could check this\nusing the .\nfunction) and getting the length of the array. Then, I’m getting pointers\nto the actual C array (which will be formatted properly as an array of\n.s because of the flags that we used in . above).\nThen, on line 34, we can finally call the C function that we wanted to wrap\nin the first place..The conditional on line 41 in the example is probably unnecessary because\nthe . function (by definition) will always return a non-negative value\nbut I wanted to include it anyways because it demonstrates how you would\nthrow an exception if something went wrong in the execution of the C code.\nThe Python interpreter has a global variable that contains a pointer to the\nmost recent exception that has been thrown. Then if a function returns .\nit starts an upwards cascade where each function either catches the exception\nusing a . statement or also returns .. When the interpreter\nreceives a . return value, it stops execution of the current code and\nshows a representation of the value of the global . variable and\nthe traceback. On line 42, if . returned a number less than zero,\nthe global . is being set to have the type . and\nthe description: “Chi-squared returned an impossible value.” Then, by\nreturning . we’re indicating that something went wrong..Finally, if . was non-negative (it’d better be), we can use\n. to\ncreate the output tuple. If . has a syntax similar to\n. then . is the analog of . with the same\nformat characters as .. Here, we don’t need to .\nthe return object because . does that for us but if you\ngenerated the output in a different way, you might have to..That’s it for the code required for our module. It might seem like a lot of\nwork but you’ll notice that we’ve only written about 120 lines of code and\nthe vast majority of these lines will be exactly the same in every module\nthat you need to write..The last thing that we need to talk about is how you might compile and\nlink this module so that it can actually be called from Python. The best\nway to do this is to use the built-in Python .. Traditionally,\nthe build script is called . and for our example, the file\nis actually extremely simple:.and you can call it using the command:.which will compile and link you source code and create a shared object\ncalled . in the same directory. Then, from Python, you can do\nthe following:.Hopefully, after going through this tutorial, you should be able to write\nyour own C-extension module especially if it is just a single C function\nthat you want to wrap. In general, I find that most of my time is spent\ncopy-and-pasting when I’m writing a C extension and once you get the hang\nof it it shouldn’t take too much effort to incorporate code like this into\nprojects that you’re working on. Since so much of this structure is the same\nacross projects, it would be awesome if someone wanted to make an interactive\ntool for auto-generating skeleton code but I haven’t seen anything like this\nyet..To see all the source code for this tutorial in one place, you can\ncheck out . or clone the\nrepository using .:.If you have any comments, suggestions or questions, . or ..",
        "",
        "",
        "",
        "",
        "\n.\n.\nThis chapter describes SWIG's support of Python.  SWIG is compatible\nwith most recent Python versions including Python 3.0 and Python 2.6,\nas well as older versions dating back to Python 2.0.  For the best results,\nconsider using Python 2.3 or newer.\n.\nThis chapter covers most SWIG features, but certain low-level details\nare covered in less depth than in earlier chapters.  At the\nvery least, make sure you read the \".\" chapter.\n.\nTo build Python extension modules, SWIG uses a layered approach in which\nparts of the extension module are defined in C and other parts are \ndefined in Python.  The C layer contains low-level wrappers whereas Python code\nis used to define high-level features.\n.\nThis layered approach recognizes the fact that certain aspects of\nextension building are better accomplished in each language (instead\nof trying to do everything in C or C++). Furthermore, by generating code in both\nlanguages, you get a lot more flexibility since you can enhance the extension\nmodule with support code in either language.\n.\nIn describing the Python interface, this chapter starts by covering the\nbasics of configuration, compiling, and installing Python modules.\nNext, the Python interface to common C and C++ programming features is\ndescribed.  Advanced customization features such as typemaps are then\ndescribed followed by a discussion of low-level implementation\ndetails.\n.\nSuppose that you defined a SWIG module such as the following:\n.\nThe . line inserts a macro that specifies that the\nresulting C file should be built as a python extension, inserting the module\n. code. This . file wraps the following simple C file:\n.\nWith the header file:\n.\nTo build a Python module, run SWIG using the . option:\n.\nIf building a C++ extension, add the . option:\n.\nThis creates two different files; a C/C++ source file . or\n. and a Python source file ..   The generated C\nsource file contains the low-level wrappers that need to be compiled and linked with the\nrest of your C/C++ application to create an extension module. The Python source file\ncontains high-level support code. This is the file that you will import to use the module.\n.\nThe name of the wrapper file is derived from the name of the input file.  For example, if the\ninput file is ., the name of the wrapper file is ..\nTo change this, you can use the . option.   The name of the Python file is derived\nfrom the module name specified with ..  If the module name is .,\nthen a file . is created.\n.\nThe following sections have further practical examples and details on\nhow you might go about compiling and using the generated files.\n.\nThe preferred approach to building an extension module for python is to compile it with\ndistutils, which comes with all recent versions of python\n(.).\n.\nDistutils takes care of making sure that your extension is built with all the correct\nflags, headers, etc. for the version of Python it is run with. Distutils will compile your\nextension into a shared object file or DLL (. on Linux, . on\nWindows, etc). In addition, distutils can handle installing your package into\nsite-packages, if that is desired. A configuration file (conventionally called: .)\ndescribes the extension (and related python modules). The distutils will\nthen generate all the right compiler directives to build it for you.\n.\nHere is a sample . file for the above example:\n.\nIn this example, the line: . creates an Extension\nmodule object, defining the name as ., and using the source code files:\n., generated by swig, and ., your original c\nsource. The swig (and other python extension modules) tradition is for the compiled\nextension to have the name of the python portion, prefixed by an underscore. If the name\nof your python module is \".\", then the name of the corresponding object file\nwill be\".\"\n.\nThe . call then sets up distutils to build your package, defining\nsome meta data, and passing in your extension module object.\nOnce this is saved as ., you can build your extension with these commands:\n.\nAnd a .so, or .pyd or... will be created for you. It will build a version that matches the\npython that you run the command with. Taking apart the command line:\n.\nThe distutils have many other features, consult the python distutils docs for details.\n.\nThis same approach works on all platforms if the appropriate compiler is installed. (it\ncan even build extensions to the standard Windows Python using MingGW)\n.\nWhile the preferred approach to building an extension module is to use the distutils, some\npeople like to integrate building extensions with a larger build system, and thus may wish\nto compile their modules without the distutils. To do this, you need to compile your\nprogram using commands like this (shown for Linux):\n.\nThe exact commands for doing this vary from platform to platform. \nHowever, SWIG tries to guess the right options when it is installed.  Therefore, \nyou may want to start with one of the examples in the . \ndirectory.   If that doesn't work, you will need to read the man-pages for\nyour compiler and linker to get the right set of options.  You might also\ncheck the . for\nadditional information.\n.\nWhen linking the module, ..  If the name of your module is \".\", then the\nname of the corresponding object file should be\n\".\" or \".\".\nThe name of the module is specified using the . directive or the \n. command line option.\n.\n. In SWIG-1.3.13 and earlier releases, module\nnames did not include the leading underscore.  This is because modules\nwere normally created as C-only extensions without the extra Python\nsupport file (instead, creating Python code was supported as an optional\nfeature).  This has been changed in SWIG-1.3.14 and is consistent with\nother Python extension modules.  For example, the .\nmodule actually consists of two files; . and\n..  Many other built-in Python modules follow a similar convention.\n.\nAn alternative approach to dynamic linking is to rebuild the Python\ninterpreter with your extension module added to it.  In the past,\nthis approach was sometimes necessary due to limitations in dynamic loading\nsupport on certain machines.  However, the situation has improved greatly\nover the last few years and you should not consider this approach \nunless there is really no other option.\n.\nThe usual procedure for adding a new module to Python involves finding\nthe Python source, adding an entry to the . file,\nand rebuilding the interpreter using the Python Makefile.  However,\nnewer Python versions have changed the build process.  You may need to edit\nthe 'setup.py' file in the Python distribution instead.\n.\nIn earlier versions of SWIG, the . library file could be used to\nrebuild the interpreter.  For example:\n.\nThe . library file includes supporting code that\ncontains everything needed to rebuild Python. To rebuild the interpreter,\nyou simply do something like this:\n.\nYou will need to supply the same libraries that were used to build Python the first\ntime.  This may include system libraries such as ., .,\nand ..  Assuming this actually works, the new version of Python\nshould be identical to the default version except that your extension module will be\na built-in part of the interpreter.\n.\n. In practice, you should probably try to avoid static\nlinking if possible. Some programmers may be inclined\nto use static linking in the interest of getting better performance.\nHowever, the performance gained by static linking tends to be rather\nminimal in most situations (and quite frankly not worth the extra\nhassle in the opinion of this author). \n.\n. The . library file is\ndeprecated and has not been maintained for several years.  Even though it\nappears to \"work\" with Python 2.1, no future support is guaranteed.\nIf using static linking, you might want to rely on a different approach\n(perhaps using distutils).\n.\nTo use your module, simply use the Python . statement. If\nall goes well, you will be able to this:\n.\nA common error received by first-time users is the following:\n.\nIf you get this message, it means that you either forgot to compile the wrapper\ncode into an extension module or you didn't give the extension module the right\nname.  Make sure that you compiled the wrappers into a module called ..  And\ndon't forget the leading underscore (_).\n.\nAnother possible error is the following:\n.\nThis error is almost always caused when a bad name is given to the shared object file. \nFor example, if you created a file . instead of . you would \nget this error.  Alternatively, this error could arise if the name of the module is\ninconsistent with the module name supplied with the . directive.\nDouble-check the interface to make sure the module name and the shared object\nfilename match.  Another possible cause of this error is forgetting to link the SWIG-generated\nwrapper code with the rest of your application when creating the extension module.\n.\nAnother common error is something similar to the following:\n.\nThis error usually indicates that you forgot to include some object\nfiles or libraries in the linking of the shared library file.  Make\nsure you compile both the SWIG wrapper file and your original program\ninto a shared library file.  Make sure you pass all of the required libraries\nto the linker.  \n.\nSometimes unresolved symbols occur because a wrapper has been created\nfor a function that doesn't actually exist in a library.  This usually\noccurs when a header file includes a declaration for a function that\nwas never actually implemented or it was removed from a library\nwithout updating the header file.  To fix this, you can either edit\nthe SWIG input file to remove the offending declaration or you can use\nthe . directive to ignore the declaration.\n.\nFinally, suppose that your extension module is linked with another library like this:\n.\nIf the . library is compiled as a shared library, you might encounter the following\nproblem when you try to use your module:\n.\nThis error is generated because the dynamic linker can't locate the\n. library.  When shared libraries are loaded, the\nsystem normally only checks a few standard locations such as\n. and ..   To fix this problem,\nthere are several things you can do.  First, you can recompile your extension\nmodule with extra path information. For example, on Linux you can do this:\n.\nAlternatively, you can set the . environment variable to\ninclude the directory with your shared libraries. \nIf setting ., be aware that setting this variable can introduce\na noticeable performance impact on all other applications that you run.\nTo set it only for Python, you might want to do this instead:\n.\nFinally, you can use a command such as . (Linux) or\n. (Solaris) to add additional search paths to the default\nsystem configuration (this requires root access and you will need to\nread the man pages).\n.\nCompilation of C++ extensions has traditionally been a tricky problem.\nSince the Python interpreter is written in C, you need to take steps to\nmake sure C++ is properly initialized and that modules are compiled\ncorrectly. This should be a non-issue if you're using distutils, as\nit takes care of all that for you. The following is included for\nhistorical reasons, and in case you need to compile on your own.\n.\nOn most machines, C++ extension modules should be linked using the C++\ncompiler.  For example:\n.\nThe -fPIC option tells GCC to generate position-independent code (PIC)\nwhich is required for most architectures (it's not vital on x86, but\nstill a good idea as it allows code pages from the library to be shared between\nprocesses).  Other compilers may need a different option specified instead of\n-fPIC.\n.\nIn addition to this, you may need to include additional library\nfiles to make it work.  For example, if you are using the Sun C++ compiler on\nSolaris, you often need to add an extra library . like this:\n.\nOf course, the extra libraries to use are completely non-portable---you will \nprobably need to do some experimentation.\n.\nSometimes people have suggested that it is necessary to relink the\nPython interpreter using the C++ compiler to make C++ extension modules work.\nIn the experience of this author, this has never actually appeared to be\nnecessary.   Relinking the interpreter with C++ really only includes the \nspecial run-time libraries described above---as long as you link your extension \nmodules with these libraries, it should not be necessary to rebuild Python.\n.\nIf you aren't entirely sure about the linking of a C++ extension, you\nmight look at an existing C++ program.  On many Unix machines, the\n. command will list library dependencies.  This should give\nyou some clues about what you might have to include when you link your\nextension module. For example:\n.\nAs a final complication, a major weakness of C++ is that it does not\ndefine any sort of standard for binary linking of libraries.  This\nmeans that C++ code compiled by different compilers will not link\ntogether properly as libraries nor is the memory layout of classes and\ndata structures implemented in any kind of portable manner.  In a\nmonolithic C++ program, this problem may be unnoticed.  However, in Python, it\nis possible for different extension modules to be compiled with\ndifferent C++ compilers.  As long as these modules are self-contained,\nthis probably won't matter.  However, if these modules start sharing data,\nyou will need to take steps to avoid segmentation faults and other\nerratic program behavior.   If working with lots of software components, you\nmight want to investigate using a more formal standard such as COM.\n.\nOn platforms that support 64-bit applications (Solaris, Irix, etc.),\nspecial care is required when building extension modules.  On these\nmachines, 64-bit applications are compiled and linked using a different\nset of compiler/linker options.  In addition, it is not generally possible to mix \n32-bit and 64-bit code together in the same application.\n.\nTo utilize 64-bits, the Python executable will need to be recompiled\nas a 64-bit application.  In addition, all libraries, wrapper code,\nand every other part of your application will need to be compiled for\n64-bits.  If you plan to use other third-party extension modules, they\nwill also have to be recompiled as 64-bit extensions.\n.\nIf you are wrapping commercial software for which you have no source\ncode, you will be forced to use the same linking standard as used by\nthat software.  This may prevent the use of 64-bit extensions.  It may\nalso introduce problems on platforms that support more than one\nlinking standard (e.g., -o32 and -n32 on Irix).\n. On the Linux x86_64 platform (Opteron or EM64T), besides of the\nrequired compiler option -fPIC discussed above, you will need to be\ncareful about the libraries you link with or the library path you\nuse. In general, a Linux distribution will have two set of libraries,\none for native x86_64 programs (under /usr/lib64), and another for 32\nbits compatibility (under /usr/lib). Also, the compiler options -m32\nand -m64 allow you to choose the desired binary format for your python\nextension.\n.\nBuilding a SWIG extension to Python under Windows is roughly similar to\nthe process used with Unix. Using the distutils, it is essentially\nidentical. If you have the same version of the MS compiler that Python\nwas built with (the python2.4 and python2.5 distributed by python.org\nare built with Visual Studio 2003), the standard . should just work.\n.\nAs of python2.5, the distutils support building extensions with MingGW out\nof the box. Following the instruction here:\n. should get you started.\n.\nIf you need to build it on your own, the following notes are provided:\n.\nYou will need to create a DLL that can be loaded into the interpreter. \nThis section briefly describes the use of SWIG with Microsoft Visual\nC++.   As a starting point, many of SWIG's examples include project\nfiles.  You might want to take a quick look at these in addition to\nreading this section.\n.\nIn Developer Studio, SWIG should be invoked as a custom build option.\nThis is usually done as follows:\n.\nIf all went well, SWIG will be automatically invoked whenever\nyou build your project.  Any changes made to the interface file will\nresult in SWIG being automatically executed to produce a new version of\nthe wrapper file. \n.\nTo run your new Python extension, simply run Python\nand use the . command as normal. For example :\n.\nIf you get an . exception when importing the module, you may\nhave forgotten to include additional library files when you built your module.\nIf you get an access violation or some kind of general protection fault \nimmediately upon import, you have a more serious problem.   This \nis often caused by linking your extension module against the wrong \nset of Win32 debug or thread libraries.  You will have to fiddle around with\nthe build options of project to try and track this down.\n.\nSome users have reported success in building extension modules using Cygwin\nand other compilers.  However, the problem of building usable DLLs with these\ncompilers tends to be rather problematic.  For the latest information,\nyou may want to consult the ..\n.\nBy default, SWIG tries to build a very natural Python interface\nto your C/C++ code.  Functions are wrapped as functions, classes are wrapped as classes, and so forth.\nThis section briefly covers the essential aspects of this wrapping.\n.\nThe SWIG . directive specifies the name of the Python\nmodule. If you specify `.', then everything is\nwrapped into a Python '.' module.  Underneath the covers,\nthis module consists of a Python source file . and a low-level\nextension module .. When choosing a\nmodule name, make sure you don't use the same name as a built-in\nPython command or standard module name.  \n.\nGlobal functions are wrapped as new Python built-in functions.  For example,\n.\ncreates a built-in function . that works exactly\nlike you think it does:\n.\nC/C++ global variables are fully supported by SWIG.  However, the underlying\nmechanism is somewhat different than you might expect due to the way that\nPython assignment works.  When you type the following in Python\n.\n\"a\" becomes a name for an object containing the value 3.4. If you later type\n.\nthen \"a\" and \"b\" are both names for the object containing the value\n3.4. Thus, there is only one object containing 3.4 and \"a\"\nand \"b\" are both names that refer to it. This is quite\ndifferent than C where a variable name refers to a memory location in which\na value is stored (and assignment copies data into that location). \nBecause of this, there is no direct way to map variable \nassignment in C to variable assignment in Python.\n.\nTo provide access to C global variables, SWIG creates a special\nobject called `.' that is added to each SWIG generated\nmodule. Global variables are then accessed as attributes of this object.\nFor example, consider this interface\n.\nNow look at the Python interface:\n.\nIf you make an error in variable assignment, you will receive an\nerror message.  For example:\n.\nIf a variable is declared as ., it is wrapped as a\nread-only variable.  Attempts to modify its value will result in an\nerror.\n.\nTo make ordinary variables read-only, you can use the . directive. For example:\n.\nThe . directive stays in effect until it is explicitly disabled or cleared using\n..\nSee the . section for further details.\n.\nIf you just want to make a specific variable immutable, supply a declaration name.  For example:\n.\nIf you would like to access variables using a name other than \".\", it can be\nchanged using the . option :\n.\nSome care is in order when importing multiple SWIG modules.\nIf you use the \".\" style of\nimporting, you will get a name clash on the variable `.'\nand you will only be able to access global variables from the last\nmodule loaded. To prevent this, you might consider renaming\n. or making it private to the module by giving it a name\nthat starts with a leading underscore. SWIG does not create .\nif there are no global variables in a module.\n.\nC/C++ constants are installed as Python objects containing the\nappropriate value.  To create a constant, use ., ., or the\n. directive.  For example:\n.\nFor enums, make sure that the definition of the enumeration actually appears in a header\nfile or in the wrapper file somehow---if you just stick an enum in a SWIG interface without\nalso telling the C compiler about it, the wrapper code won't compile.\n.\nNote:  declarations declared as . are wrapped as read-only variables and\nwill be accessed using the . object described in the previous section.  They\nare not wrapped as constants.   For further discussion about this, see the . chapter.\n.\nConstants are not guaranteed to remain constant in Python---the name\nof the constant could be accidentally reassigned to refer to some\nother object.  Unfortunately, there is no easy way for SWIG to\ngenerate code that prevents this.  You will just have to be careful.\n.\nC/C++ pointers are fully supported by SWIG.  Furthermore, SWIG has no\nproblem working with incomplete type information.  Here is a rather\nsimple interface:\n.\nWhen wrapped, you will be able to use the functions in a natural way from Python. For example:\n.\nIf this makes you uneasy, rest assured that there is no\ndeep magic involved.  Underneath the covers, pointers to C/C++ objects are\nsimply represented as opaque values using an especial python container object:\n.\nThis pointer value can be freely passed around to different C functions that\nexpect to receive an object of type ..  The only thing you can't do is \ndereference the pointer from Python. Of course, that isn't much of a concern in this example.\n.\nIn older versions of Swig (1.3.22 or older), pointers were represented\nusing a plain string object. If you have an old package that still\nrequires that representation, or you just feel nostalgic, you can\nalways retrieve it by casting the pointer object to a string:\n.\nAlso, if you need to pass the raw pointer value to some external\npython library, you can do it by casting the pointer object to an\ninteger:\n.\nHowever, the inverse operation is not possible, i.e., you can't build\na Swig pointer object from a raw integer value.\n.\nNote also that the '0' or NULL pointer is always represented by\n., no matter what type swig is addressing. In the\nprevious example, you can call:\n.\nand that will be equivalent to the following, but not really useful, C\ncode:\n.\nAs much as you might be inclined to modify a pointer value directly\nfrom Python, don't.  The hexadecimal encoding is not necessarily the\nsame as the logical memory address of the underlying object.  Instead\nit is the raw byte encoding of the pointer value.  The encoding will\nvary depending on the native byte-ordering of the platform (i.e.,\nbig-endian vs. little-endian).  Similarly, don't try to manually cast\na pointer to a new type by simply replacing the type-string.  This may\nnot work like you expect, it is particularly dangerous when casting\nC++ objects.  If you need to cast a pointer or change its value,\nconsider writing some helper functions instead.  For example:\n.\nAlso, if working with C++, you should always try\nto use the new C++ style casts.  For example, in the above code, the\nC-style cast may return a bogus result whereas as the C++-style cast will return\n. if the conversion can't be performed.\n.\nIf you wrap a C structure, it is wrapped by a Python class.  This provides\na very natural interface.  For example,\n.\nis used as follows:\n.\nSimilar access is provided for unions and the data members of C++ classes.\n.\nIf you print out the value of . in the above example, you will see\nsomething like this:\n.\nThis object is actually a Python instance that has been wrapped around a pointer to the low-level\nC structure.  This instance doesn't actually do anything--it just serves as a proxy.\nThe pointer to the C object can be found in the the .\nattribute.  For example:\n.\nFurther details about the Python proxy class are covered a little later.\n.\n. members of a structure are read-only. Data members\ncan also be forced to be read-only using the . directive. For example:\n.\nWhen . members of a structure are wrapped, the contents are assumed to be\ndynamically allocated using . or . (depending on whether or not\nSWIG is run with the -c++ option).   When the structure member is set, the old contents will be \nreleased and a new value created.   If this is not the behavior you want, you will have to use\na typemap (described later).\n.\nIf a structure contains arrays, access to those arrays is managed through pointers.  For\nexample, consider this:\n.\nIf accessed in Python, you will see behavior like this:\n.\nThis pointer can be passed around to functions that expect to receive\nan . (just like C).   You can also set the value of an array member using\nanother pointer.  For example:\n.\nFor array assignment, SWIG copies the entire contents of the array starting with the data pointed\nto by ..   In this example, 16 integers would be copied.  Like C, SWIG makes\nno assumptions about bounds checking---if you pass a bad pointer, you may get a segmentation\nfault or access violation.\n.\nWhen a member of a structure is itself a structure, it is handled as a\npointer.  For example, suppose you have two structures like this:\n.\nNow, suppose that you access the . attribute of . like this:\n.\nIn this case, . is a pointer that points to the . that is inside ..\nThis is the same value as generated by this C code:\n.\nBecause the pointer points inside the structure, you can modify the contents and \neverything works just like you would expect. For example:\n.\nC++ classes are wrapped by Python classes as well. For example, if you have this class,\n.\nyou can use it in Python like this:\n.\nClass data members are accessed in the same manner as C structures.  \n.\nStatic class members present a special problem for Python.  Prior to Python-2.2, \nPython classes had no support for static methods and no version of Python\nsupports static member variables in a manner that SWIG can utilize.  Therefore, \nSWIG generates wrappers that try to work around some of these issues.  To illustrate,\nsuppose you have a class like this:\n.\nIn Python, the static member can be access in three different ways:\n.\nThe first two methods of access are supported in all versions of Python.  The\nlast technique is only available in Python-2.2 and later versions.\n.\nStatic member variables are currently accessed as global variables.  This means,\nthey are accessed through . like this:\n.\nSWIG is fully aware of issues related to C++ inheritance.  Therefore, if you have\nclasses like this\n.\nthose classes are wrapped into a hierarchy of Python classes that reflect the same inheritance\nstructure.   All of the usual Python utility functions work normally:\n.\nFurthermore, if you have functions like this\n.\nthen the function . accepts . or a pointer to any class derived from ..\n.\nIt is safe to use multiple inheritance with SWIG.\n.\nIn C++, there are many different ways a function might receive\nand manipulate objects.  For example:\n.\nIn Python, there is no detailed distinction like this--specifically,\nthere are only \"objects\".  There are no pointers, references, arrays,\nand so forth.  Because of this, SWIG unifies all of these types\ntogether in the wrapper code.  For instance, if you actually had the\nabove functions, it is perfectly legal to do this:\n.\nSimilar behavior occurs for return values.  For example, if you had\nfunctions like this,\n.\nthen all three functions will return a pointer to some . object.\nSince the third function (spam8) returns a value, newly allocated memory is used \nto hold the result and a pointer is returned (Python will release this memory \nwhen the return value is garbage collected). The fourth case (spam9)\nwhich returns a const reference, in most of the cases will be \ntreated as a returning value, and it will follow the same\nallocation/deallocation process.\n.\nC++ overloaded functions, methods, and constructors are mostly supported by SWIG.  For example,\nif you have two functions like this:\n.\nYou can use them in Python in a straightforward manner:\n.\nSimilarly, if you have a class like this,\n.\nyou can write Python code like this:\n.\nOverloading support is not quite as flexible as in C++. Sometimes there are methods that SWIG\ncan't disambiguate. For example:\n.\nor\n.\nIf declarations such as these appear, you will get a warning message like this:\n.\nTo fix this, you either need to ignore or rename one of the methods.  For example:\n.\nor\n.\nSWIG resolves overloaded functions and methods using a disambiguation scheme that ranks and sorts\ndeclarations according to a set of type-precedence rules.    The order in which declarations appear\nin the input does not matter except in situations where ambiguity arises--in this case, the\nfirst declaration takes precedence.\n.\nPlease refer to the \"SWIG and C++\" chapter for more information about overloading. \n.\nCertain C++ overloaded operators can be handled automatically by SWIG.  For example,\nconsider a class like this:\n.\nWhen wrapped, it works like you expect:\n.\nOne restriction with operator overloading support is that SWIG is not\nable to fully handle operators that aren't defined as part of the class.\nFor example, if you had code like this\n.\nthen SWIG ignores it and issues a warning.   You can still wrap the operator,\nbut you may have to encapsulate it in a special function.  For example:\n.\nThere are ways to make this operator appear as part of the class using the . directive.\nKeep reading.\n.\nAlso, be aware that certain operators don't map cleanly to Python.  For instance,\noverloaded assignment operators don't map to Python semantics and will be ignored.\n.\nSWIG is aware of C++ namespaces, but namespace names do not appear in\nthe module nor do namespaces result in a module that is broken up into\nsubmodules or packages.  For example, if you have a file like this,\n.\nit works in Python as follows:\n.\nIf your program has more than one namespace, name conflicts (if any) can be resolved using .\nFor example:\n.\nIf you have more than one namespace and your want to keep their\nsymbols separate, consider wrapping them as separate SWIG modules.\nFor example, make the module name the same as the namespace and create\nextension modules for each namespace separately.  If your program\nutilizes thousands of small deeply nested namespaces each with\nidentical symbol names, well, then you get what you deserve.\n.\nC++ templates don't present a huge problem for SWIG.  However, in order\nto create wrappers, you have to tell SWIG to create wrappers for a particular\ntemplate instantiation.  To do this, you use the . directive.\nFor example:\n.\nIn Python:\n.\nObviously, there is more to template wrapping than shown in this example.\nMore details can be found in the . chapter.  \nSome more complicated\nexamples will appear later.\n.\nIn certain C++ programs, it is common to use classes that have been wrapped by\nso-called \"smart pointers.\"   Generally, this involves the use of a template class\nthat implements . like this:\n.\nThen, if you have a class like this,\n.\nA smart pointer would be used in C++ as follows:\n.\nTo wrap this in Python, simply tell SWIG about the . class and the low-level\n. object.  Make sure you instantiate . using . if necessary.\nFor example:\n.\nNow, in Python, everything should just \"work\":\n.\nIf you ever need to access the underlying pointer returned by . itself,\nsimply use the . method.  For example:\n.\nAnother usual idiom in C++ is the use of reference counted\nobjects. Consider for example:\n\n.\n.\nIn the example above, the 'A' class instance 'a' is a reference counted\nobject, which can't be deleted arbitrarily since it is shared between\nthe objects 'b1' and 'b2'. 'A' is derived from an Reference Counted\nObject 'RCObj', which implements the ref/unref idiom.\n.\n.\nTo tell SWIG that 'RCObj' and all its derived classes are reference\ncounted objects, you use the \"ref\" and \"unref\" features, or\n. and . directives (since 1.3.28). For example:\n.\n.\n\nor, using the directive form:\n\n\n.\n.\nwhere the code passed to the \"ref\" and \"unref\" features will be\nexecuted as needed whenever a new object is passed to python, or when\npython tries to release the shadow object instance, respectively. \n.\n. \nIn the python side, the use of a reference counted object is not\ndifferent than any other regular instance:\n.\n.\n.\nNote that the user doesn't explicitly need to call 'a->ref()' nor 'a->unref()'\n(as neither 'delete a'). Instead, SWIG take cares of executing the \"ref\"\nand \"unref\" codes as needed.  If the user doesn't specify the\n\"ref/unref\" features, SWIG will produce a code equivalent to define\nthem as:\n.\n.\n.\nIn other words, SWIG will not do anything special when a new object\nis passed to python, and it will always 'delete' the object when\npython releases the proxy instance.\n.\n.\n.\nIn the previous section, a high-level view of Python wrapping was\npresented.  A key component of this wrapping is that structures and\nclasses are wrapped by Python proxy classes.  This provides a very\nnatural Python interface and allows SWIG to support a number of\nadvanced features such as operator overloading.   However, a number\nof low-level details were omitted.  This section provides a brief overview\nof how the proxy classes work.\n.\n.\n.\nIn the . and . chapters,\ndetails of low-level structure and class wrapping are described.  To summarize those chapters, if you\nhave a class like this\n.\n.\n.\nthen SWIG transforms it into a set of low-level procedural wrappers. For example:\n.\n.\n.\nThese wrappers can be found in the low-level extension module (e.g., .).\n.\n.\nUsing these wrappers, SWIG generates a high-level Python proxy class (also known as a shadow class) like this (shown \nfor Python 2.2):\n.\n.\n.\nThis class merely holds a pointer to the underlying C++ object (.) and dispatches methods and \nmember variable access to that object using the low-level accessor functions.   From a user's point of\nview, it makes the class work normally:\n.\n.\n.\nThe fact that the class has been wrapped by a real Python class offers certain advantages.  For instance,\nyou can attach new Python methods to the class and you can even inherit from it (something not supported\nby Python built-in types until Python 2.2).\n.\n.\n.\nAssociated with proxy object, is an ownership flag .   The value of this\nflag determines who is responsible for deleting the underlying C++ object.   If set to 1,\nthe Python interpreter will destroy the C++ object when the proxy class is \ngarbage collected.   If set to 0 (or if the attribute is missing), then the destruction\nof the proxy class has no effect on the C++ object.\n.\n.\nWhen an object is created by a constructor or returned by value, Python automatically takes\nownership of the result.  For example:\n.\n.\n.\nIn Python:\n.\n.\n.\nOn the other hand, when pointers are returned to Python, there is often no way to know where\nthey came from.  Therefore, the ownership is set to zero.  For example:\n.\n.\n.\n.\n.\nThis behavior is especially important for classes that act as\ncontainers.  For example, if a method returns a pointer to an object\nthat is contained inside another object, you definitely don't want\nPython to assume ownership and destroy it!\n.\n.\nA good way to indicate that ownership should be set for a returned pointer\nis to use the ..\n.\n.\nRelated to containers, ownership issues can arise whenever an object is assigned to a member\nor global variable.  For example, consider this interface:\n.\n.\n.\nWhen wrapped in Python, careful observation will reveal that ownership changes whenever an object\nis assigned to a global variable.  For example:\n.\n.\n.\nIn this case, C is now holding a reference to the object---you probably don't want Python to destroy it.\nSimilarly, this occurs for members.  For example:\n.\n.\n.\nFor the most part, memory management issues remain hidden.  However,\nthere are occasionally situations where you might have to manually\nchange the ownership of an object.  For instance, consider code like this:\n.\n.\n.\nNow, consider the following Python code:\n.\n.\n.\nIn this case, the object . is holding a reference to\n. internally.  However, SWIG has no way to know that this\nhas occurred.  Therefore, Python still thinks that it has ownership of the\nobject.  Should the proxy object be destroyed, then the C++ destructor\nwill be invoked and . will be holding a stale-pointer.  If\nyou're lucky, you will only get a segmentation fault.\n.\n.\nTo work around this, it is always possible to flip the ownership flag. For example,\n.\n.\n.\nIt is also possible to deal with situations like this using\ntypemaps--an advanced topic discussed later.\n.\n.\n.\nSWIG makes every attempt to preserve backwards compatibility with\nolder versions of Python to the extent that it is possible.  However,\nin Python-2.2, an entirely new type of class system was introduced.\nThis new-style class system offers many enhancements including static\nmember functions, properties (managed attributes), and class methods.\nDetails about all of these changes can be found on . and is not repeated here.\n.\n.\nTo address differences between Python versions, SWIG currently emits\ndual-mode proxy class wrappers.  In Python-2.2 and newer releases,\nthese wrappers encapsulate C++ objects in new-style classes that take\nadvantage of new features (static methods and properties).  However,\nif these very same wrappers are imported into an older version of Python, \nold-style classes are used instead.\n.\n.\nThis dual-nature of the wrapper code means that you can create extension\nmodules with SWIG and those modules will work with all versions of Python\nranging from Python-1.4 to the very latest release.  Moreover, the wrappers take\nadvantage of Python-2.2 features when available.\n.\n.\nFor the most part, the interface presented to users is the same regardless\nof what version of Python is used.  The only incompatibility lies in the handling\nof static member functions.  In Python-2.2, they can be accessed via the\nclass itself.  In Python-2.1 and earlier, they have to be accessed as a global\nfunction or through an instance (see the earlier section).\n.\n.\n.\nProxy classes provide a more natural, object-oriented way to access\nextension classes. As described above, each proxy instance has an\nassociated C++ instance, and method calls to the proxy are passed to the\nC++ instance transparently via C wrapper functions.\n.\n.\nThis arrangement is asymmetric in the sense that no corresponding\nmechanism exists to pass method calls down the inheritance chain from\nC++ to Python. In particular, if a C++ class has been extended in Python\n(by extending the proxy class), these extensions will not be visible\nfrom C++ code. Virtual method calls from C++ are thus not able access\nthe lowest implementation in the inheritance chain.\n.\n.\nChanges have been made to SWIG 1.3.18 to address this problem and\nmake the relationship between C++ classes and proxy classes more\nsymmetric. To achieve this goal, new classes called directors are\nintroduced at the bottom of the C++ inheritance chain. The job of the\ndirectors is to route method calls correctly, either to C++\nimplementations higher in the inheritance chain or to Python\nimplementations lower in the inheritance chain. The upshot is that C++\nclasses can be extended in Python and from C++ these extensions look\nexactly like native C++ classes. Neither C++ code nor Python code needs\nto know where a particular method is implemented: the combination of\nproxy classes, director classes, and C wrapper functions takes care of\nall the cross-language method routing transparently.\n.\n.\n.\nThe director feature is disabled by default.  To use directors you\nmust make two changes to the interface file.  First, add the \"directors\"\noption to the %module directive, like this:\n.\n.\n.\nWithout this option no director code will be generated.  Second, you\nmust use the %feature(\"director\") directive to tell SWIG which classes \nand methods should get directors.  The %feature directive can be applied \nglobally, to specific classes, and to specific methods, like this:\n.\n.\n.\nYou can use the %feature(\"nodirector\") directive to turn off\ndirectors for specific classes or methods.  So for example,\n.\n.\n.\nwill generate directors for all virtual methods of class Foo except\nbar().  \n.\n.\nDirectors can also be generated implicitly through inheritance. \nIn the following, class Bar will get a director class that handles\nthe methods one() and two() (but not three()):\n.\n.\n.\nthen at the python side you can define\n.\n.\n.\n.\nFor each class that has directors enabled, SWIG generates a new class\nthat derives from both the class in question and a special\n. class. These new classes, referred to as director\nclasses, can be loosely thought of as the C++ equivalent of the Python\nproxy classes. The director classes store a pointer to their underlying\nPython object and handle various issues related to object ownership.\nIndeed, this is quite similar to the \"this\" and \"thisown\" members of the\nPython proxy classes.\n.\n.\nFor simplicity let's ignore the . class and refer to the\noriginal C++ class as the director's base class. By default, a director\nclass extends all virtual methods in the inheritance chain of its base\nclass (see the preceding section for how to modify this behavior).\nThus all virtual method calls, whether they originate in C++ or in\nPython via proxy classes, eventually end up in at the implementation in\nthe director class. The job of the director methods is to route these\nmethod calls to the appropriate place in the inheritance chain. By\n\"appropriate place\" we mean the method that would have been called if\nthe C++ base class and its extensions in Python were seamlessly\nintegrated. That seamless integration is exactly what the director\nclasses provide, transparently skipping over all the messy extension API\nglue that binds the two languages together.\n.\n.\nIn reality, the \"appropriate place\" is one of only two possibilities:\nC++ or Python. Once this decision is made, the rest is fairly easy. If\nthe correct implementation is in C++, then the lowest implementation of\nthe method in the C++ inheritance chain is called explicitly. If the\ncorrect implementation is in Python, the Python API is used to call the\nmethod of the underlying Python object (after which the usual virtual\nmethod resolution in Python automatically finds the right\nimplementation).\n.\n.\nNow how does the director decide which language should handle the method call?\nThe basic rule is to handle the method in Python, unless there's a good\nreason not to. The reason for this is simple: Python has the most\n\"extended\" implementation of the method. This assertion is guaranteed,\nsince at a minimum the Python proxy class implements the method. If the\nmethod in question has been extended by a class derived from the proxy\nclass, that extended implementation will execute exactly as it should.\nIf not, the proxy class will route the method call into a C wrapper\nfunction, expecting that the method will be resolved in C++. The wrapper\nwill call the virtual method of the C++ instance, and since the director\nextends this the call will end up right back in the director method. Now\ncomes the \"good reason not to\" part. If the director method were to blindly\ncall the Python method again, it would get stuck in an infinite loop. We avoid this\nsituation by adding special code to the C wrapper function that tells\nthe director method to not do this. The C wrapper function compares the\npointer to the Python object that called the wrapper function to the\npointer stored by the director. If these are the same, then the C\nwrapper function tells the director to resolve the method by calling up\nthe C++ inheritance chain, preventing an infinite loop.\n.\n.\nOne more point needs to be made about the relationship between director\nclasses and proxy classes. When a proxy class instance is created in\nPython, SWIG creates an instance of the original C++ class and assigns\nit to .. This is exactly what happens without directors and\nis true even if directors are enabled for the particular class in\nquestion. When a class . from a proxy class is created,\nhowever, SWIG then creates an instance of the corresponding C++ director\nclass. The reason for this difference is that user-defined subclasses\nmay override or extend methods of the original class, so the director\nclass is needed to route calls to these methods correctly. For\nunmodified proxy classes, all methods are ultimately implemented in C++\nso there is no need for the extra overhead involved with routing the\ncalls through Python.\n.\n.\n.\nMemory management issues are slightly more complicated with directors\nthan for proxy classes alone. Python instances hold a pointer to the\nassociated C++ director object, and the director in turn holds a pointer\nback to the Python object. By default, proxy classes own their C++\ndirector object and take care of deleting it when they are garbage\ncollected.\n.\n.\nThis relationship can be reversed by calling the special\n. method of the proxy class. After calling this\nmethod, the . flag is set to zero, and the director\nclass increments the reference count of the Python object. When the\ndirector class is deleted it decrements the reference count. Assuming no\noutstanding references to the Python object remain, the Python object\nwill be destroyed at the same time. This is a good thing, since\ndirectors and proxies refer to each other and so must be created and\ndestroyed together. Destroying one without destroying the other will\nlikely cause your program to segfault.\n.\n.\nTo help ensure that no references to the Python object remain after\ncalling ., this method returns a weak reference to\nthe Python object. Weak references are only available in Python versions\n2.1 and higher, so for older versions you must explicitly delete all\nreferences. Here is an example:\n.\n.\n.\n.\n.\nIn this example, we are assuming that FooContainer will take care of\ndeleting all the Foo pointers it contains at some point.  Note that no hard\nreferences to the Foo objects remain in Python.\n.\n.\n.\nWith directors routing method calls to Python, and proxies routing them\nto C++, the handling of exceptions is an important concern. By default, the\ndirectors ignore exceptions that occur during method calls that are\nresolved in Python. To handle such exceptions correctly, it is necessary\nto temporarily translate them into C++ exceptions. This can be done with\nthe %feature(\"director:except\") directive. The following code should\nsuffice in most cases:\n.\n.\n.\nThis code will check the Python error state after each method call from\na director into Python, and throw a C++ exception if an error occurred.\nThis exception can be caught in C++ to implement an error handler.\nCurrently no information about the Python error is stored in the\nSwig::DirectorMethodException object, but this will likely change in\nthe future.\n.\n.\nIt may be the case that a method call originates in Python, travels up\nto C++ through a proxy class, and then back into Python via a director\nmethod. If an exception occurs in Python at this point, it would be nice\nfor that exception to find its way back to the original caller. This can\nbe done by combining a normal %exception directive with the\n. handler shown above. Here is an example of a\nsuitable exception handler:\n.\n.\n.\nThe class Swig::DirectorException used in this example is actually a\nbase class of Swig::DirectorMethodException, so it will trap this\nexception. Because the Python error state is still set when\nSwig::DirectorMethodException is thrown, Python will register the\nexception as soon as the C wrapper function returns.\n.\n.\n.\nEnabling directors for a class will generate a new director method for\nevery virtual method in the class' inheritance chain. This alone can\ngenerate a lot of code bloat for large hierarchies. Method arguments\nthat require complex conversions to and from target language types can\nresult in large director methods. For this reason it is recommended that\nyou selectively enable directors only for specific classes that are\nlikely to be extended in Python and used in C++.\n.\n.\nCompared to classes that do not use directors, the call routing in the\ndirector methods does add some overhead. In particular, at least one\ndynamic cast and one extra function call occurs per method call from\nPython. Relative to the speed of Python execution this is probably\ncompletely negligible. For worst case routing, a method call that\nultimately resolves in C++ may take one extra detour through Python in\norder to ensure that the method does not have an extended Python\nimplementation. This could result in a noticeable overhead in some cases.\n.\n.\nAlthough directors make it natural to mix native C++ objects with Python\nobjects (as director objects) via a common base class pointer, one\nshould be aware of the obvious fact that method calls to Python objects\nwill be much slower than calls to C++ objects. This situation can be\noptimized by selectively enabling director methods (using the %feature\ndirective) for only those methods that are likely to be extended in\nPython.\n.\n.\n.\nTypemaps for input and output of most of the basic types from director\nclasses have been written. These are roughly the reverse of the usual\ninput and output typemaps used by the wrapper code. The typemap\noperation names are 'directorin', 'directorout', and 'directorargout'.\nThe director code does not currently use any of the other kinds of typemaps.\nIt is not clear at this point which kinds are appropriate and\nneed to be supported.\n.\n.\n.\nDirector typemaps for STL classes are in place, and hence you should\nbe able to use std::vector, std::string, etc., as you would any other type.\n.\n.\n. The director typemaps for return types based in const\nreferences, such as \n\n.\n.\nwill work only for simple call scenarios. Usually the resulting code\nis neither thread or reentrant safe. Hence, the user is advised to\navoid returning const references in director methods. For example,\nthe user could modify the method interface to use lvalue return\ntypes, wherever possible, for example\n.\n.\n.\nIf that is not possible, the user should avoid enabling the\ndirector feature for reentrant, recursive or threaded member\nmethods that return const references.\n.\n.\n.\nThe last section presented the absolute basics of C/C++ wrapping. If\nyou do nothing but feed SWIG a header file, you will get an interface\nthat mimics the behavior described.  However, sometimes this isn't\nenough to produce a nice module.  Certain types of functionality might\nbe missing or the interface to certain functions might be awkward.\nThis section describes some common SWIG features that are used to\nimprove your the interface to an extension module.\n.\n.\n.\nSometimes when you create a module, it is missing certain bits of functionality. For\nexample, if you had a function like this\n.\n.\n.\nit would be accessible from Python, but there may be no easy way to call it.\nFor example, you might get errors like this:\n.\n.\n.\nThe problem here is that there is no easy way to construct and manipulate a suitable\n. value to use.   To fix this, you can write some extra C helper\nfunctions.  Just use the . directive. For example:\n.\n.\n.\nFrom Python, you could then write code like this:\n.\n.\n.\nAdmittedly, this is not the most elegant looking approach.  However, it works and it wasn't too\nhard to implement.  It is possible to clean this up using Python code, typemaps, and other\ncustomization features as covered in later sections.\n.\n.\n.\nIf writing support code in C isn't enough, it is also possible to write code in\nPython.  This code gets inserted in to the . file created by SWIG.   One\nuse of Python code might be to supply a high-level interface to certain functions.\nFor example:\n.\n.\n.\nIn this example, . provides a high-level Python interface built on top of\nlow-level helper functions.  For example, this code now seems to work:\n.\n.\n.\nAdmittedly, this whole scheme for wrapping the two-dimension array\nargument is rather ad-hoc. Besides, shouldn't a Python list or a\nNumeric Python array just work normally?  We'll get to those examples\nsoon enough.  For now, think of this example as an illustration of\nwhat can be done without having to rely on any of the more advanced\ncustomization features.\n.\n.Sometimes you may want to replace or modify the wrapper function\nthat SWIG creates in the proxy . file.  The Python module\nin SWIG provides some features that enable you do do this.  First, to\nentirely replace a proxy function you can use\n..  For example:.\n.\n. where . will be replaced by the call to\nthe C/C++ proper method. \n.\n.\nOften the proxy function created by SWIG is fine, but you simply want\nto add code to it without touching the rest of the generated function\nbody.  For these cases SWIG provides the . and\n. features which do exactly as their names suggest.  The\n. feature will insert its value at the beginning of the\nproxy function, and . will insert code at the end of the\nproxy, just before the return statement.\n.\n.\n.\nNotes: Usually the . and .\nfeatures are safer to use than the . feature. Also, from\nSWIG version 1.3.28 you can use the directive forms\n.  and . as follows:.\n.\n.\n.\nOne of the more interesting features of SWIG is that it can extend\nstructures and classes with new methods--at least in the Python interface.\nHere is a simple example:\n.\n.\n.\nNow, in Python\n.\n.\n.\n. can be used for many more tasks than this.  \nFor example, if you wanted to overload a Python operator, you might do this:\n.\n.\n.\nUse it like this:\n.\n.\n.\n. works with both C and C++ code.  It does not modify the underlying object\nin any way---the extensions only show up in the Python interface.\n.\n.\n.\nIf a C or C++ function throws an error, you may want to convert that error into a Python\nexception. To do this, you can use the . directive.  .\nsimply lets you rewrite part of the generated wrapper code to include an error check.\n.\n.\nIn C, a function often indicates an error by returning a status code (a negative number\nor a NULL pointer perhaps).  Here is a simple example of how you might handle that:\n.\n.\n.\nIn Python,\n.\n.\n.\nIf a library provides some kind of general error handling framework, you can also use\nthat.  For example:\n.\n.\n.\nNo declaration name is given to ., it is applied to all wrapper functions.\n.\n.\nC++ exceptions are also easy to handle.  For example, you can write code like this:\n.\n.\n.\nWhen raising a Python exception from C, use the .\nfunction as shown above.  The following exception types can be used as the first argument.\n.\n.\n.\nThe language-independent . library file can also be used\nto raise exceptions.  See the . chapter.\n.\n.\n.\nAlthough SWIG is largely automatic, there are certain types of wrapping problems that\nrequire additional user input.    Examples include dealing with output parameters,\nstrings, binary data, and arrays.   This chapter discusses the common techniques for\nsolving these problems.\n.\n.\n.\nA common problem in some C programs is handling parameters passed as simple pointers.  For\nexample:\n.\n.\n.\nor perhaps\n.\n.\n.\nThe easiest way to handle these situations is to use the . file.  For example:\n.\n.\n.\nIn Python, this allows you to pass simple values.  For example:\n.\n.\n.\nNotice how the . parameters allow integer values to be passed instead of pointers\nand how the . parameter creates a return result.\n.\n.\nIf you don't want to use the names . or ., use the .\ndirective.  For example:\n.\n.\n.\nIf a function mutates one of its parameters like this,\n.\n.\n.\nyou can use . like this:\n.\n.\n.\nIn Python, a mutated parameter shows up as a return value.  For example:\n.\n.\n.\nNote: Since most primitive Python objects are immutable, it is not possible to\nperform in-place modification of a Python object passed as a parameter.\n.\n.\nThe most common use of these special typemap rules is to handle functions that\nreturn more than one value.   For example, sometimes a function returns a result\nas well as a special error code:\n.\n.\n.\nTo wrap such a function, simply use the . rule above. For example:\n.\n.\n.\nWhen used in Python, the function will return multiple values.  \n.\n.\n.\nAnother common use of multiple return values are in query functions.  For example:\n.\n.\n.\nTo wrap this, you might use the following:\n.\n.\n.\nNow, in Python:\n.\n.\n.\nBe aware that the primary purpose of the . file is to support primitive datatypes.\nWriting a function like this\n.\n.\n.\nmay not have the intended effect since . does not define an OUTPUT rule for ..\n.\n.\n.\nIf you must work with simple pointers such as . or . and you don't want to use\n., consider using the . library file.    For example:\n.\n.\n.\nThe . macro generates five helper functions that can be used to create,\ndestroy, copy, assign, and dereference a pointer.  In this case, the functions are as follows:\n.\n.\n.\nIn Python, you would use the functions like this:\n.\n.\n.\nIf you replace . by ., the interface is more class-like.\n.\n.\n.\nSee the . chapter for further details.\n.\n.\n.\nSometimes a C function expects an array to be passed as a pointer.  For example,\n.\n.\n.\nTo wrap this into Python, you need to pass an array pointer as the first argument. \nA simple way to do this is to use the . library file.  For example:\n.\n.\n.\nThe . macro creates wrappers for an unbounded array object that\ncan be passed around as a simple pointer like . or ..\nFor instance, you will be able to do this in Python:\n.\n.\n.\nThe array \"object\" created by . does not\nencapsulate pointers inside a special array object.  In fact, there is\nno bounds checking or safety of any kind (just like in C).  Because of\nthis, the arrays created by this library are extremely low-level\nindeed.  You can't iterate over them nor can you even query their\nlength.  In fact, any valid memory address can be accessed if you want\n(negative indices, indices beyond the end of the array, etc.).\nNeedless to say, this approach is not going to suit all applications.\nOn the other hand, this low-level approach is extremely efficient and\nwell suited for applications in which you need to create buffers,\npackage binary data, etc.\n.\n.\n.\nIf a C function has an argument of ., then a Python string\ncan be passed as input.  For example:\n.\n.\n.\n.\nWhen a Python string is passed as a parameter, the C function receives a pointer to the raw\ndata contained in the string.  Since Python strings are immutable, it is illegal\nfor your program to change the value.  In fact, doing so will probably crash the Python\ninterpreter.\n.\n.\nIf your program modifies the input parameter or uses it to return data, consider\nusing the . library file described in the . chapter.\n.\n.\nWhen functions return a ., it is assumed to be a NULL-terminated string. \nData is copied into a new Python string and returned.\n.\n.\nIf your program needs to work with binary data, you can use a typemap\nto expand a Python string into a pointer/length argument pair.   As luck would have it, \njust such a typemap is already defined. Just do this:\n.\n.\n.\nNow in Python:\n.\n.\n.\nIf you need to return binary data, you might use the\n. library file.  The . library can\nalso be used to extra binary data from arbitrary pointers.\n.\n.\n.\n.\n.\n.\nThis section describes how you can modify SWIG's default wrapping behavior\nfor various C/C++ datatypes using the . directive.   This\nis an advanced topic that assumes familiarity with the Python C API as well\nas the material in the \".\" chapter.\n.\n.\nBefore proceeding, it should be stressed that typemaps are not a required \npart of using SWIG---the default wrapping behavior is enough in most cases.\nTypemaps are only used if you want to change some aspect of the primitive\nC-Python interface or if you want to elevate your guru status.\n.\n.\n.\nA typemap is nothing more than a code generation rule that is attached to \na specific C datatype.   For example, to convert integers from Python to C,\nyou might define a typemap like this:\n.\n.\n.\nTypemaps are always associated with some specific aspect of code generation.\nIn this case, the \"in\" method refers to the conversion of input arguments\nto C/C++.  The datatype . is the datatype to which the typemap\nwill be applied.  The supplied C code is used to convert values.  In this\ncode a number of special variable prefaced by a . are used.  The\n. variable is placeholder for a local variable of type ..\nThe . variable is the input object of type ..\n.\n.\nWhen this example is compiled into a Python module, it operates as follows:\n.\n.\n.\nIn this example, the typemap is applied to all occurrences of the . datatype.\nYou can refine this by supplying an optional parameter name.  For example:\n.\n.\n.\nIn this case, the typemap code is only attached to arguments that exactly match ..\n.\n.\nThe application of a typemap to specific datatypes and argument names involves\nmore than simple text-matching--typemaps are fully integrated into the\nSWIG C++ type-system.   When you define a typemap for ., that typemap\napplies to . and qualified variations such as ..  In addition,\nthe typemap system follows . declarations.  For example:\n.\n.\n.\nTypemaps can also be defined for groups of consecutive arguments.  For example:\n.\n.\n.\nWhen a multi-argument typemap is defined, the arguments are always handled as a single\nPython object.  This allows the function to be used like this (notice how the length\nparameter is omitted):\n.\n.\n.\n.\nThe previous section illustrated an \"in\" typemap for converting Python objects to C.\nA variety of different typemap methods are defined by the Python module.  For example,\nto convert a C integer back into a Python object, you might define an \"out\" typemap\nlike this:\n.\n.\n.\nA detailed list of available methods can be found in the \".\" chapter.  \n.\n.\nHowever, the best source of typemap information (and examples) is\nprobably the Python module itself.  In fact, all of SWIG's default\ntype handling is defined by typemaps.  You can view these typemaps by\nlooking at the files in the SWIG library. Just take into account that\nin the latest versions of swig (1.3.22+), the library files are not\nvery pristine clear for the casual reader, as they used to be. The\nextensive use of macros and other ugly techniques in the latest\nversion produce a very powerful and consistent python typemap library,\nbut at the cost of simplicity and pedagogic value.\n.\n.\nTo learn how to write a simple or your first typemap, you better take\na look at the SWIG library version 1.3.20 or so.\n.\n.\n.\nWithin typemap code, a number of special variables prefaced with a . may appear.\nA full list of variables can be found in the \".\" chapter.\nThis is a list of the most common variables:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\nWhen you write a typemap, you usually have to work directly with Python objects.\nThe following functions may prove to be useful.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\nThis section includes a few examples of typemaps.  For more examples, you\nmight look at the files \".\" and \".\" in\nthe SWIG library.\n.\n.\n.\nA common problem in many C programs is the processing of command line\narguments, which are usually passed in an array of NULL terminated\nstrings.  The following SWIG interface file allows a Python list\nobject to be used as a . object.\n.\n.\n.\nWhen this module is compiled, the wrapped C function now operates as\nfollows :\n.\n.\n.\nIn the example, two different typemaps are used.  The \"in\" typemap is\nused to receive an input argument and convert it to a C array.  Since dynamic\nmemory allocation is used to allocate memory for the array, the\n\"freearg\" typemap is used to later release this memory after the execution of\nthe C function. \n.\n.\n.\nSuppose that you had a collection of C functions with arguments\nsuch as the following:\n.\n.\n.\nIn the previous example, a typemap was written to pass a Python list as the ..  This\nallows the function to be used from Python as follows:\n.\n.\n.\nAlthough this works, it's a little awkward to specify the argument count.  To fix this, a multi-argument\ntypemap can be defined.  This is not very difficult--you only have to make slight modifications to the\nprevious example:\n.\n.\n.\nWhen writing a multiple-argument typemap, each of the types is referenced by a variable such \nas . or ..   The typemap code simply fills in the appropriate values from\nthe supplied Python object.\n.\n.\nWith the above typemap in place, you will find it no longer necessary\nto supply the argument count.  This is automatically set by the typemap code.  For example:\n.\n.\n.\n.\nA common problem in some C programs is that values may be returned in\narguments rather than in the return value of a function.  For example:\n.\n.\n.\nA typemap can be used to handle this case as follows :\n.\n.\n.\nThe typemap works as follows.  First, a check is made to see if any previous result\nexists.  If so, it is turned into a tuple and the new output value is concatenated to it.\nOtherwise, the result is returned normally.   For the sample function ., there\nare three output values--meaning that the function will return a 3-tuple of the results.\n.\n.\nAs written, the function must accept 4 arguments as input values,\nlast two being pointers to doubles.  If these arguments are only used to hold output values (and have\nno meaningful input value), an additional typemap can be written.  For example:\n.\n.\n.\nBy specifying numinputs=0,  the input value is ignored.  However, since the argument still has to be set to\nsome meaningful value before calling C, it is set to point to a local variable ..  When the function\nstores its output value, it will simply be placed in this local variable.  As a result, the\nfunction can now be used as follows:\n.\n.\n.\n.\nIn some applications, it is sometimes desirable to pass small arrays\nof numbers as arguments. For example :\n.\n.\n.\nThis too, can be handled used typemaps as follows :\n.\n.\n.\nThis allows our . function to be called from\nPython as follows :\n.\n.\n.\nSince our mapping copies the contents of a Python tuple into a C\narray, such an approach would not be recommended for huge arrays, but\nfor small structures, this approach works fine.\n.\n.\n.\nSuppose that you wanted to generalize the previous example to handle C\narrays of different sizes.  To do this, you might write a typemap as follows:\n.\n.\n.\nIn this case, the variable . is expanded to match the\narray dimensions actually used in the C code. This allows the typemap\nto be applied to types such as:\n.\n.\n.\nSince the above typemap code gets inserted into every wrapper function where used, it might make sense\nto use a helper function instead.  This will greatly reduce the amount of wrapper code.  For example:\n.\n.\n.\n.\nOccasionally, it might be necessary to convert pointer values that have\nbeen stored using the SWIG typed-pointer representation.  Since there are\nseveral ways in which pointers can be represented, the following two\nfunctions are used to safely perform this conversion:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\nBoth of these functions require the use of a special SWIG\ntype-descriptor structure.  This structure contains information about\nthe mangled name of the datatype, type-equivalence information, as\nwell as information about converting pointer values under C++\ninheritance.   For a type of ., the type descriptor structure\nis usually accessed as follows:\n.\n.\n.\nIn a typemap, the type descriptor should always be accessed using the special typemap\nvariable ..  For example:\n.\n.\n.\nIf necessary, the descriptor for any type can be obtained using the . macro in a typemap.\nFor example:\n.\n.\n.\nAlthough the pointer handling functions are primarily intended for\nmanipulating low-level pointers, both functions are fully aware of\nPython proxy classes.  Specifically,\n. will retrieve a pointer from any object\nthat has a . attribute.  In addition,\n. can automatically generate a proxy\nclass object (if applicable).\n.\n.\n.\nUsing docstrings in Python code is becoming more and more important\nand more tools are coming on the scene that take advantage of them,\neverything from full-blown documentation generators to class browsers\nand popup call-tips in Python-aware IDEs.  Given the way that SWIG\ngenerates the proxy code by default, your users will normally get\nsomething like . in the popup calltip of\ntheir IDE which is next to useless when the real function prototype\nmight be something like this:\n.\n.\n.\nThe features described in this section make it easy for you to add\ndocstrings to your modules, functions and methods that can then be\nused by the various tools out there to make the programming experience\nof your users much simpler.\n.\n.\n.\nPython allows a docstring at the beginning of the . file\nbefore any other statements, and it is typically used to give a\ngeneral description of the entire module.  SWIG supports this by\nsetting an option of the . directive.  For example:\n.\n.\n.\nWhen you have more than just a line or so then you can retain the easy\nreadability of the . directive by using a macro.  For\nexample:\n.\n.\n.\n.\nAs alluded to above SWIG will generate all the function and method\nproxy wrappers with just \"*args\" (or \"*args, **kwargs\" if the -keyword\noption is used) for a parameter list and will then sort out the\nindividual parameters in the C wrapper code.  This is nice and simple\nfor the wrapper code, but makes it difficult to be programmer and tool\nfriendly as anyone looking at the . file will not be able\nto find out anything about the parameters that the functions accept.\n.\n.But since SWIG does know everything about the function it is\npossible to generate a docstring containing the parameter types, names\nand default values. Since many of the docstring tools are adopting a\nstandard of recognizing if the first thing in the docstring is a\nfunction prototype then using that instead of what they found from\nintrospection, then life is good once more.\n\n.SWIG's Python module provides support for the \"autodoc\" feature,\nwhich when attached to a node in the parse tree will cause a docstring\nto be generated that includes the name of the function, parameter\nnames, default values if any, and return type if any. There are also\nthree options for autodoc controlled by the value given to the\nfeature, described below.\n\n.\n.\nWhen the \"0\" option is given then the types of the parameters will\n. be included in the autodoc string.  For example, given\nthis function prototype:\n.\n.\n.\nThen Python code like this will be generated:\n.\n.\n.\n.\nWhen the \"1\" option is used then the parameter types . be\nused in the autodoc string.  In addition, an attempt is made to\nsimplify the type name such that it makes more sense to the Python\nuser.  Pointer, reference and const info is removed,\n.'s are evaluated, etc.  (This is not always\nsuccessful, but works most of the time.  See the next section for what\nto do when it doesn't.)  Given the example above, then turning on the\nparameter types with the \"1\" option will result in Python code like\nthis:\n.\n.\n.\n.\nFinally, there are times when the automatically generated autodoc\nstring will make no sense for a Python programmer, particularly when a\ntypemap is involved.  So if you give an explicit value for the autodoc\nfeature then that string will be used in place of the automatically\ngenerated string.  For example:\n.\n.\n.\n.\nIn addition to the autodoc strings described above, you can also\nattach any arbitrary descriptive text to a node in the parse tree with\nthe \"docstring\" feature.  When the proxy module is generated then any\ndocstring associated with classes, function or methods are output.\nIf an item already has an autodoc string then it is combined with the\ndocstring and they are output together.  If the docstring is all on a\nsingle line then it is output like this::\n.\n.\n.\nOtherwise, to aid readability it is output like this:\n.\n.\n.\n.\nUsing the . option of the . directive\nallows you to specify what Python package that the module will be\nliving in when installed.\n.\n.\n.\nThis is useful when the . file is .ed by\nanother . file.  By default SWIG will assume that the\nimporter is able to find the importee with just the module name, but\nif they live in separate Python packages then that won't work.\nHowever if the importee specifies what its package is with the\n. option then the Python code generated for the\nimporter will use that package name when importing the other module\nand also in base class declarations, etc. if the package name is\ndifferent than its own.\n.\n.\n.\nSWIG is able to support Python 3.0. The wrapper code generated by\nSWIG can be compiled with both Python 2.x or 3.0. Further more, by\npassing the . command line option to SWIG, wrapper code\nwith some Python 3 specific features can be generated (see below\nsubsections for details of these features). The . option also\ndisables some incompatible features for Python 3, such as\n..\n\n.\nThere is a list of known-to-be-broken features in Python 3:\n.\n.\n.\nThe following are Python 3.0 new features that are currently supported by\nSWIG.\n.\n.\n.\nThe . option will enable function annotation support. When used\nSWIG is able to generate proxy method definitions like this:\n.\n.\n.\nAlso, even if without passing SWIG the . option, the parameter list\nstill could be generated:\n.\n.\n.\nBut for overloaded function or method, the parameter list would fallback to\n. or ., and . may be append\ndepend on whether you enabled the keyword argument. This fallback is due to\nall overloaded functions share the same function in SWIG generated proxy class.\n.\n.\nFor detailed usage of function annotation, see PEP 3107.\n.\n.\n.\nBuffer protocols were revised in Python 3. SWIG also gains a series of\nnew typemaps to support buffer interfaces. These typemap macros are\ndefined in ., which must be included in order to use them.\nBy using these typemaps, your wrapped function will be able to\naccept any Python object that exposes a suitable buffer interface.\n.\n.\nFor example, the . function puts the path string\ninto the memory pointed to by its argument:\n.\n.\n.\nThen you can write a typemap like this: (the following example is\napplied to both Python 3.0 and 2.6, since the . type\nis backported to 2.6.\n.\n.\n.\nAnd then on the Python side the wrapped . could be used in this\nway:\n.\n.\n.\nThe macros defined in . are similar to those in\n.:\n.\n.\n.\n.\n.\nThe macro can be used to generate a typemap which maps a buffer of an\nobject to a pointer provided by . and a size argument\nprovided by .. For example:\n.\nIn Python:\n.\n.\n.\n.\n.\nThis typemap macro requires the buffer to be a zero terminated string,\nand maps the pointer of the buffer to .. For example:\n.\nIn Python:\n.\nBoth . and .\nrequire the provided buffer to be mutable, eg. they can accept a \n. type but can't accept an immutable .\ntype.\n.\n.\n.\n.\n.\nThis macro maps an object's buffer to a pointer . and a\nsize .. It is similar to\n., except the\n. an accept both mutable and immutable\nbuffers. As a result, the wrapped function should not modify the buffer.\n.\n.\n.\n.\n.\nThis macro maps an object's buffer as a string pointer ..\nIt is similar to . but the buffer\ncould be both mutable and immutable. And your function should not\nmodify the buffer.\n.\n.\n.\nBy including . and using the . command\nline option when calling SWIG, the proxy classes of the STL containers\nwill automatically gain an appropriate abstract base class. For\nexample, the following SWIG interface:\n.\n.\n.\nwill generate a Python proxy class . inheriting from\n. and a proxy class .\ninheriting from ..\n.\n.\n. also provides a macro . that could be\nused to define an abstract base class for your own C++ class:\n.\n.\n.\nFor details of abstract base class, please see PEP 3119.\n.\n",
        "\nThe language of choice for large, high-performance applications\nin Linux is almost always C, or somewhat less often C++. Both are\npowerful languages that allow you to create high-performance natively\ncompiled programs. However, they are not languages that lend themselves\nto runtime flexibility. Once a C/C++ application is compiled, its code is\npretty much static. At times, that can be a real hindrance. For example,\nif you want to allow users of a program to create plugins easily that\nextend the application's functionality, you have to deal with complex\ndynamic linking issues that can cause no end of headaches. Additionally,\nyour users will have to know C/C++ in order to extend the application,\nwhich severely limits the number of people capable of writing extensions.\n.\nA much better solution is to provide your users with a scripting language\nthey can use to extend your application. With a scripting language,\nyou will tend to have much more runtime flexibility, as well as shorter\ndevelopment times and a lower learning curve that will extend the base\nof users capable of creating extensions.\n.\nUnfortunately, creating a scripting language is very much a nontrivial\ntask that easily could become a major portion of your program.\nFortunately, you don't need to create a scripting language. With Python,\nyou can embed the interpreter directly into your application and expose\nthe full power and flexibility of Python without adding very much code\nat all to your application.\n.\nIncluding the Python interpreter in your program is extremely simple.\nPython provides a single header file for including all of the definitions\nyou need when embedding the interpreter into your application,\naptly named Python.h. This contains a lot of stuff, including several of\nthe standard headers. For compiling efficiency, it might be nice if you\ncould include only those parts of the interface that you actually intend\nto use, but unfortunately Python doesn't really give you that option.\nIf you take a look at the Python.h file, you'll see that it defines\nseveral important macros and includes a number of common headers that\nare required by the individual components included later in the file.\n.\nTo link your application to the Python interpreter at compile time,\nyou should run the python-config program to get a list of the linking\noptions that should be passed to the compiler. On my system, those are:\n\n.\nSo, how much code does it take to run the Python interpreter from a\nC app? As it turns out, very little. In fact, if you look at Listing\n1, you'll see that it can be done in as little as three lines of code,\nwhich initialize the interpreter, send it a string of Python code to\nexecute and then shut the interpreter back down.\n.\nOr, you could embed an interactive Python terminal in your program by\ncalling Py_Main() instead, as in Listing 2. This brings up the\ninterpreter just as if you'd run Python directly from the command line.\nControl is returned to your application after the user exits from\nthe interpreter shell.\n.\nEmbedding the interpreter in three lines of code is easy enough,\nbut let's face it, just executing arbitrary strings of Python code inside\na program is neither interesting nor all that useful. Fortunately,\nit's also far from the extent of what Python allows. Before I get too\ndeep into what it can do though, let's take a look at initializing the\nenvironment that Python executes within.\n.\nWhen you run the Python interpreter, the main environment context is\nstored in the __main__ module's namespace dictionary. All functions,\nclasses and variables that are defined globally can be found in this\ndictionary. When running Python interactively or on a script file, you\nrarely need to care about this global namespace. However, when running\nthe embedded interpreter, you'll often need to access this dictionary to\nget references to functions or classes in order to call or construct them.\nYou also may find that you occasionally want to copy the global dictionary\nso that different bits of code can be run in distinct environments.\nFor instance, you might want to create a new environment for each plugin\nthat you load.\n.\nTo get at the __main__ module's dictionary, you first need to\nget a reference to the module. You can do this by calling the\nPyImport_AddModule() function, which looks up the module name you\nsupply and returns a PyObject pointer to that object. Why a PyObject?\nAll Python data types derive from PyObject, which makes it a handy\nlowest-common denominator. Therefore, almost all of the functions that you'll\ndeal with when interacting with the Python interpreter will take or return\npointers to PyObjects rather than another more specific Python data type.\n.\nOnce you have the __main__ module referenced by a PyObject, you can\nuse the PyModule_GetDict() function to get a reference to the main\nmodule's dictionary, which again is returned as a PyObject pointer.\nYou can then pass the dictionary reference when you execute other Python\ncommands. For example, Listing 3 shows how you could duplicate the\nglobal environment and execute two different Python files in separate\nenvironments.\n.\nI'll get into the details of how PyRun_File() works in a little bit,\nbut if you look carefully at Listing 3, you should notice something\ninteresting. When I call PyRun_File() to execute the files, the\ndictionary gets passed in twice. The reason for this is that Python\ncode actually has two environmental contexts when it is executed.\nThe first is the global context, which I've already talked about.\nThe second context is the local context, which contains any locally\ndefined variables or functions. In this case, those are the same, because\nthe code being executed is top-level code. On the other hand, if you\nwere to execute a function dynamically using multiple C-level calls,\nyou might want to create a local context and use that instead of the\nglobal dictionary. For the most part though, it's generally safe to\npass the global environment for both the global and local parameters.\n.\nAt this point, I'm sure you've noticed the Py_DECREF() calls that\npopped up in the Listing 3 example. Those fun little guys are there\nfor memory management purposes. Inside the interpreter, Python handles\nmemory management automatically by keeping track of all references to\nmemory transparent to the programmer. As soon as it determines that all\nreferences to a given chunk of memory have been released, it deallocates\nthe no-longer needed chunk. This can be a problem when you start working\non the C side though. Because C is not a memory-managed language, as soon\nas a Python data structure ends up referenced from C, all ability to track\nthe references automatically is lost to Python. The C application can make as many\ncopies of the reference that it wants, and hold on to it indefinitely\nwithout Python knowing anything about it.\n.\nThe solution is to have C code that gets a reference to a Python object\nhandle all of the reference counting manually. Generally, when a Python\ncall hands an object out to a C program, it increments the reference count\nby one. The C code can then do what it likes with the object without worrying\nthat it will be deleted out from under it. Then when the C program is\ndone with the object, it is responsible for releasing its reference by\nmaking a call to Py_DECREF().\n.\nIt's important, though, to remember when you copy a pointer within\nyour C program that may outlast the pointer from which you're copying, you\nneed to increment the reference count manually, by calling Py_INCREF().\nFor example, if you make a copy of a PyObject pointer to store inside\nan array, you'll probably want to call Py_INCREF() to ensure that\nthe pointed-to object won't get garbage-collected after the original\nPyObject reference is decremented.\n.\nNow let's take a look at a slightly more useful example to see how Python\ncan be embedded into a real program. If you take a look at Listing\n4, you'll see a small program that allows the user to specify short\nexpressions on the command line. The program then calculates the\nresults of those expressions and displays them in the output. To add a\nlittle spice to the mix, the program also lets users specify a file\nof Python code that will be loaded before the expressions are executed.\nThis way, the user can define functions that will be available to the\ncommand-line expressions.\n.\nTwo basic Python API functions are used in this program,\nPyRun_SimpleString() and PyRun_AnyFile(). You've seen PyRun_SimpleString()\nbefore. All it does is execute the given Python expression\nin the global environment. PyRun_SimpleFile() is similar to the\nPyRun_File() function that I discussed earlier, but it runs things in the\nglobal environment by default. Because everything is run in the\nglobal environment, the results of each executed expression or group of\nexpressions will be available to those that are executed later.\n.\nNow, let's say that instead of having our expression calculator execute\na list of expressions, you'd rather have it load a function f() from\nthe Python file and execute it a variable number of times to calculate\nan aggregate total, based on a number provided on the command line.\nYou could execute the function simply by running\n.,\nbut that's really not very efficient, as it requires the interpreter\nto parse and evaluate the string every time it's called. It would be\nmuch better if we could reference the function directly to call it.\n.\nIf you recall, Python stores all globally defined functions in the\nglobal dictionary. Therefore, if you can get a reference to the global\ndictionary, you can extract a reference to any of the defined functions.\nFortunately, the Python API provides functions for doing just that.\nYou can see it in use by taking a look at Listing 5.\n.\nTo obtain the function reference, the program first gets a reference to the\nmain module by “importing” it using the PyImport_AddModule(\"__main__\")\nfunction. Once it has this reference to the main module, the program uses\nthe PyModule_GetDict() function to extract its dictionary. From there, it's simply a matter of calling PyDict_GetItemString(global_dict, \"f\")\nto extract the function from the dictionary.\n.\nNow that the program has a reference to the function, it can call it using\nthe PyObject_CallObect() function. As you can see, this takes a pointer\nto the function object to call. Because the function itself already exists\nin the Python environment, it is already compiled. That means when\nyou perform the call, there is no parsing and little or no compilation\noverhead, which means the function can be executed quite quickly.\n.\nAt this point, I'm sure you're starting to think, “Gee whiz, this is\ngreat but it would be a whole lot better if I could actually pass some\ndata to these functions I'm calling.” Well, you need wonder no longer.\nAs it turns out, you can do exactly that. One way is through the use of that\nmysterious NULL value that you saw being passed to PyObject_CallObject in\nListing 5. I'll talk about how that works in a bit, but first there is\na much easier way to call functions with arguments that are in the form\nof C/C++ data types, PyObject_CallFunction(). Instead of requiring you\nto perform C-to-Python conversions, this handy function takes a format\nstring and a variable number of arguments, much like the printf() family\nof functions.\n.\nLooking back at our calculator program, let's say you want to evaluate\nan expression over a range of noncontiguous values. If the expression\nto evaluate is defined in a function provided by the loaded Python\nfile, you can get a reference as normal and then iterate over the\nrange. For each value, simply call PyObject_CallFunction(expression,\n\"i\", num). The “i” string tells Python that you will be passing an\ninteger as the only argument. If the function you were calling took two\nintegers and a string instead, you could make the function call as\nPyObject_CallFunction(expression, \"iis\", num1, num2, string). If the\nfunction has a return value, it will be passed to you in the return value\nof PyObject_CallFunction(), as a PyObject pointer.\n.\nThat's the easiest way to pass arguments to a Python function, but\nit's not actually the most flexible. Think about it for a second.\nWhat happens if you are dynamically choosing the function to call?\nThe odds are that you're going to want the flexibility to call a variety\nof functions that accept different numbers and types of arguments.\nHowever, with PyObject_CallFunction(), you have to choose the number and\ntype of the arguments at compile time, which hardly fits with the spirit\nof flexibility inherent in embedding a scripting language.\n.\nThe solution is to use PyObject_CallObject() instead. This function\nallows you to pass a single tuple of Python objects instead of the\nvariable-length list of native C data items. The downside here is that\nyou will need to convert native C values to Python objects first, but\nwhat you lose in execution speed is made up for in flexibility. Of course,\nbefore you can pass values to your function as a Python tuple, you'll\nneed to know how to create the tuple, which brings me to the next section.\n.\nPython data structures are returned from and passed to the Python\ninterpreter in the form of PyObjects. To get to a specific type,\nyou need to perform a cast to the correct type. For instance,\nyou can get to a PyIntObject pointer by casting a PyObject pointer.\nIf you don't know for sure what the variable's type is, though, blindly\nperforming a cast could have disastrous results. In such a case, you can\ncall one of the many Check() functions to see if an object is indeed of\nan appropriate type, such as the PyFloat_Check() function that returns\ntrue if the object could indeed be cast to a float. In other words,\nit returns true if the object is a float or a subtype of a float.\nIf you'd rather know whether the object is exactly a float, not a subclass,\nyou can use PyFloat_CheckExact().\n.\nThe opaque PyObject structure isn't actually useful to a C program\nthough. In order to access Python data in your program, you'll need to use\na variety of conversion functions that will return a native C type.\nFor example, if you want to convert a PyObject to a long int, you can\nrun PyInt_AsLong(). PyInt_AsLong is a safe function, and will perform\na checked casting to PyIntObject before extracting the long int value.\nIf you know for sure that the value you're converting is indeed an\nint, it may be wasteful to perform the extra checking—especially\nif it's inside of a tight loop.\n.\nOften, Python functions ask for or return Python sequence objects, such\nas tuples or lists. These objects don't have directly corresponding\ntypes in C, but Python provides functions that allow you to build them\nfrom C data types. As an example, let's take a look at building a tuple\nsince you'll need to be able to do that to call a function\nusing PyObject_CallObject().\n.\nThe first step to creating a new tuple is to construct an empty tuple\nwith PyTuple_New(), which takes the length of the tuple and returns a\nPyObject pointer to a new tuple. You can then use PyTuple_SetItem to set\nthe values of the tuple items, passing each value as a PyObject pointer.\n.\nYou should now have enough to get started with embedding Python scripts\ninside your own applications. For more information, take a look at the\nPython documentation. “Extending and Embedding the Python\nInterpreter”\ngoes into more detail on going the other direction and embedding C\nfunctions inside Python. The “Python/C API Reference Manual” also\nhas detailed reference documentation on all of the functions available\nfor embedding Python in your program. The . archives also\ncontain an excellent article from Ivan Pulleyn that discusses issues\nfor multithreaded programs that embed Python.\n.\n..\n.\nWilliam Nagel is the Chief Software Engineer for Stage\nLogic, LLC, a small software development company, where he develops\nreal-time systems based on Linux. He is also the author of\n“Subversion Version Control: Using the Subversion Version Control\nSystem in Development Projects”.\n",
        "",
        "",
        "",
        "\n.\n.\n\tCorporation for National Research Initiatives (CNRI) \n.\n1895 Preston White Drive, Reston, Va 20191, USA \n.\nE-mail: ., .\n.\n.\n.\n.\n.Table of Child-Links.\n.\n.End of Table of Child-Links.\n.\n.\n.End of Navigation Panel.\n",
        "",
        "",
        "",
        "\n.START_SECTION_8.END_SECTION_8.START_SECTION_11.END_SECTION_11.\n.This job is open to telecommute candidates..Applicants must be authorized to work in the U.S..\n. is recruiting for this position and the positions below..\n.\n.\r\n                        All qualified applicants will receive consideration for employment without regard to race, color, religion, sex, national origin, disability, protected veteran status, or any other characteristic protected by law.\r\n                    .\n. – In compliance with federal law, all persons hired will be required to verify identity and eligibility to work in the United States and to complete the required employment eligibility verification document form upon hire.\r\n                    ",
        "",
        "",
        "",
        "\n            An array is a collection of elements stored at contiguous memory locations. Even if you're a beginner, you've likely heard of them as they're the most used data structures in programming.\n    .\n            You must know how to perform basic operations on an array like finding the sum of elements of an array, finding the product of elements of an array, reversing an array, finding the largest and smallest element in an array, etc. to be fully prepared for coding interviews.\n    .\n            In this article, you'll learn how to find the mean of an array using Python, C++, JavaScript, and C.\n    .\n            You're given an array .. You need to find the mean of ..\n    .\n.: Let arr = [1, 2, 3, 4, 5, 6, 7, 8]\n    .\n            Mean of arr = (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8) / 8 = 4.5\n    .\n            Thus, the output is ..\n    .\n.: Let arr = [1, 1, 1, 1, 1, 1]\n    .\n            Mean of arr = (1 + 1 + 1 + 1 + 1 + 1) / 6 = 1\n    .\n            Thus, the output is ..\n    .\n.:\n    .\n            Mean of an array = sum of all elements of the array / total no. of elements in the array\n    .\n            You can find the mean of an array by following the approach outlined below:\n    .\n            Below is the C++ program to find the mean of an array:\n    .\n.:\n    .\n.\n.\n            Below is the Python program to find the mean of an array:\n    .\n.:\n    .\n.\n.\n            Below is the JavaScript program to find the mean of an array:\n    .\n.:\n    .\n.\n.\n            Below is the C program to find the mean of an array:\n    .\n.:\n    .\n.\n.\n            Arrays are one of the most asked topics in programming interviews. It's wise to practice some of the most common problems based on arrays like finding the maximum and minimum elements of an array, finding the product of all elements in an array, removing duplicate elements from an array, reversing an array, sorting an array, etc. if you're serious about getting a job in the programming field.\n    .Yuvraj is a Computer Science undergraduate student at the University of Delhi, India. He's passionate about Full Stack Web Development. When he's not writing, he's exploring the depth of different technologies..Join our newsletter for tech tips, reviews, free ebooks, and exclusive deals!",
        "Java and Python are both high-level object-oriented programming languages. Sometimes they need to invoke code implemented in a lower level language like C++, C, and assembly for the sake of faster calculations, finer control over memory layout, or machine-specific features..I have worked with the standard foreign function interface (FFI) in both languages – . and . – and found interesting differences in the architecture of their functions and data values. By comparing and contrasting the two languages, I hope to illustrate that JNI and CPython take diametrically opposite approaches in many aspects. Both approaches are appropriate for their respective language environment, but would fare poorly in the other language – neither way is right or wrong in an absolute sense..Here are two complete application examples in both Java and Python. Download all the files in ., or view individual files below:.The first program, “Sum array”, demonstrates how native C code can read numbers coming from Java/Python code. The comparison is not fair because Java has primitive integer types whereas Python only has bigint objects. The Java version shows how the Java primitive types easily correspond to C integer types, and how arrays of numbers are accessed in JNI. The Python version shows how to convert between Python’s . objects and native C integer types..The second program, “Create map”, demonstrates how native C code can create a complex graph of Java or Python objects. The Java version looks up existing Java classes and methods, builds strings in C, then invokes the Java methods to create the necessary objects. The Python version looks up one custom function, but otherwise invokes statically known global C functions to create and manipulate Python objects; note that we need to pay attention to reference counts and handle reference stealing and decrementing properly. In this demonstration, there is a fairly good correspondence between the native code in the JNI and CPython versions, because they both take an object-oriented approach to structuring the data..The C code for Python only works with the CPython 3 interpreter, not Python 2 or a different interpreter. The C code for Java should work with all compliant JDK and JVM implementations..The entire . has just under 70 unique functions as of Java 8. (This is the number once you merge the raw functions that are simply variations on return type or argument style.) This API is surprisingly compact, and you can reasonably memorize the 10 to 20 most commonly used functions after a bit of practice, and rarely need to refer to the documentation thereafter..Notes:.In the list above, the function names come from the JNI API, but the subheading names and the way the functions are grouped are made by Nayuki (not a part of any official specification)..Working with static methods and fields uses a different API than working with instance methods/fields. This differs from how the java.lang.reflect API treats both cases the same..All of the JNI string functions are for convenience and not strictly necessary. Their functionalities can still be accomplished tediously using numerous reflection function calls and temporary values..The list of Python/C API functions/macros is enormous, and has over 700 entries as of CPython 3.5. Some very low-level or esoteric functions were arbitrarily excluded by me. An explicit list of entries can be found in .. A summary of function counts per topic is given below:",
        "Ask Ubuntu is a question and answer site for Ubuntu users and developers. It only takes a minute to sign up..Q&A for work.Connect and share knowledge within a single location that is structured and easy to search..I was wondering if there are any libraries for ., . or . that help you interface with your window manager/x-windows? I am currently using . and feeding it . bash commands and though this kind of works it feels very dirty..I've found a couple of libraries that try to do this, but they are all from 2016 (or way older) and usually version 0.something which is kinda questionable. I am . looking for something like . or a different window manager as I frankly quite enjoy the Gnome window manager, I just want to extend it slightly with some personalized scripts..I'd prefer it if the libraries are in Python, C or C++ but if you know of some which are written in different languages I'd be happy to hear about those too :D.Have a look at ...API docs for the Python bindings are ., you need to install the package . to use them..It should be usable with C++, too, but I've never tried that..\r\n                                                By clicking “Post Your Answer”, you agree to our ., . and .\n.\r\n                        Your privacy\r\n                    .\r\n                        By clicking “Accept all cookies”, you agree Stack Exchange can store cookies on your device and disclose information in accordance with our ..\r\n                    ",
        "Top coders have near limitless prospects when it comes to employment, or even opportunities to succeed in their own startups. In fact, . is fast becoming a necessary life skill, with millions each year taking online and in-person courses to learn Python, Java, and other popular ...But which one will give you the most bang for your buck?.Even if you're ., it's an investment of your time. You want to be sure you're learning the language that will be most useful for you. .Of course, much of your decision about which coding language to start out on depends on what you want to be able to do or create with it. Learning Python makes sense if you want to develop video games or GUIs (graphic user interfaces) like Instagram. It's one of the official programming languages at Google, and the average Python developer salary in the U.S. is $107,000..Sounds pretty good, right?.But then, Ruby is a pretty awesome language too. Ruby is one of the easiest coding languages to learn, and there's a massive, active community around it, with Ruby meetups in every major city around the world. On average, Ruby developers command salaries in the area of $102,000, with Amazon being one of the top employers..You might want to learn C if you plan on developing software, hardware, or even operating systems. C is a ., because a lot of other languages have borrowed directly or indirectly from it, including Java and JavaScript, C++, Python, PHP, and Perl. Intel, Amazon, and Dell are all major employers for C programmers, who make an average of $102,000 a year..The infographic below was designed to help you .. It includes the nine most popular programming languages: Python, Java, C, C++, JavaScript, C#, Ruby, PHP, and Objective-C..For each programming language, you can see what top coders have used it to build, how much each offers as an average salary, the pros and cons of that coding language, and more..First-time developers: . you have! Check out the top coding languages below, and see which one makes the most sense to take on first..Whether you decide to learn Python, Ruby, or C# (or any other language), you're increasing your career prospects and gaining a valuable life skill that will serve you well in whatever you do next!. Image credit:",
        "\n.\r\n\t\t\t .\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tLaunch Eclipse. A screen like this should appear, where you can choose which workspace to open. \r\n\t\t\t\t\t\t\t(If not, go to . )\r\n\t\t\t\t\t\t.\r\n\t\t\t\t\t\t\tBrowse the csse120 folder \r\n\t\t\t\t\t\t\twhich you created when installing Eclipse. Select \"Use this as the default and do not ask again\". \r\n\t\t\t\t\t\t.If you do, Eclipse will automatically use this \r\n\t\t\t\t\t\t\tworkspace next time you open Eclipse. If you want to change the workspace later you can always go to\r\n\t\t\t\t\t\t\t\t\t\t.... \r\n\t\t\t\t\t\t\tto be sent back to the Workspace Launcher window. .\r\n\t\t\t\t\t\t\tYou should now see Eclipse's Welcome screen: \r\n\t\t\t\t\t\t.\r\n\t\t\t\t\t\t\tClick on the arrow on the right to go to the workbench.\r\n\t\t\t\t\t\t.\r\n\t\t\t\t\t\t\tThis is where you'll do most of your work in Eclipse. \r\n\t\t\t\t\t\t.\r\n\t\t\t\t\t\t\tEnter . \r\n\t\t\t\t\t\t\tin the .  \r\n\t\t\t\t\t\t\tfield. \r\n\t\t\t\t\t\t.\r\n\t\t\t\t\t\t\tAfter several seconds, two options should appear. Select the . option. \r\n\t\t\t\t\t\t\tDo .select the \"PyDev Mylyn Integration\" flag.\r\n\t\t\t\t\t\t.\n.\r\n\t\t\t\t\t\t\tGo to . \r\n\t\t\t\t\t\t\tIn the Preferences window, expand\r\n\t\t\t\t\t\t\t. and select \r\n\t\t\t\t\t\t\t.. \r\n\t\t\t\t\t\t.\r\n\t\t\t\t\t\t\tClick \"New...\" and type . for the Interpreter name. \r\n\t\t\t\t\t\t\tFor the Interpreter executable, browse to your copy of Python (.), \r\n\t\t\t\t\t\t\tand press Open.\r\n\t\t\t\t\t\t.\n.\n.\n.\r\n\t\t\t\t\t\t\tClick \"OK\" and the  . Window will appear. \r\n\t\t\t\t\t\t.\n.\n. Unzip this \r\n\t\t\t\t\t\t., placing its sole unzipped file\r\n\t\t\t\t\t\t.in any \r\n\t\t\t\t\t\tconvenient location (your desktop, My Documents folder, \r\n\t\t\t\t\t\tetc).\r\n\t\t\t\t\t\t.Launch Eclipse.\r\n\t\t\t\t\t.If Eclipse offers to Select a Workspace, \r\n\t\t\t\t\t\t\t\t\tbrowse to\r\n\t\t\t\t\t\t\t\t\tC:\\EclipseWorkspace\\csse120..If the csse 120 workspace does not appear \r\n\t\t\t\t\t\t\t\t\tautomatically, choose ., \r\n\t\t\t\t\t\t\t\t\tand click ...\r\n\t\t\t\t\tNow you are ready to set the preferences for the workspace:.Choose File → Import.In the Import dialog box, select General → Preferences and click Next..When the Import Preferences dialog opens, select Browse \r\n\t\t\t\t\tand find the EclipsePreferences-2011-06.epf file that you \r\n\t\t\t\t\tunzipped and saved above..Back in the Import Preferences dialog, check Import All, \r\n\t\t\t\t\tthen select Finish..As before, if the Subclipse Usage dialog makes an \r\n\t\t\t\t\tappearance, uncheck the box and continue. .Confirm that the installation did not leave behind \r\n\t\t\t\t\tunintended files by checking if there is:.random .eclipse folder anywhere, possibly \r\n\t\t\t\t\t\t\t\t\tin the folder immediately above My \r\n\t\t\t\t\t\t\t\t\tDocuments..Any extra users (for example, the \r\n\t\t\t\t\t\t\t\t\tinstaller), in \r\n\t\t\t\t\t\t\t\t\tC:\\Users.Extra Eclipse workspaces anywhere except \r\n\t\t\t\t\t\t\t\t\tfor the folders inside C:\\EclipseWorkspaces..\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tGo to . and choose \r\n\t\t\t\t\t\t\t., \r\n\t\t\t\t\t\t\tthen click OK. If you look at the upper right corner you will see that the perspective has changed from \"Java\" to \"PyDev\". \r\n\t\t\t\t\t\t.\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPerspectives are designed to have the most useful \r\n\t\t\t\t\t\t\ttools within reach for whatever task you are doing \r\n\t\t\t\t\t\t\t(for example writing Java code or writing Python \r\n\t\t\t\t\t\t\tcode). If you look in the . menu you will see that there are different options with the different perspective. \r\n\t\t\t\t\t\t.\r\n\t\t\t\t\t\t\tAs you can see, perspectives greatly affect the look of the Eclipse program. \r\n\t\t\t\t\t\t.\r\n\t\t\t\t\t\t\tIn the next window that appears, enter the name of your project and select \"python\"  \r\n\t\t\t\t\t\t\tand 3.0\"; as the type. Make sure \"create default 'src' folder and add it to the pythonpath?\" is selected. Click Finish. \r\n\t\t\t\t\t\t.\r\n\t\t\t\t\t\t\tIf you look at the upper left corner of the workspace (in the \r\n\t\t\t\t\t\t\t\tPackage Explorer \r\n\t\t\t\t\t\t\t.\r\n\t\t\t\t\t\t\tview), you should now see your newly created project with a \"src\" folder inside. \r\n\t\t\t\t\t\t.\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tSelect the project you just created and go to\r\n\t\t\t\t\t\t\t.. \r\n\t\t\t\t\t\t\tThis will launch a new PyDev Module Wizard where you should enter a name for your module and \r\n\t\t\t\t\t\t\tmake sure it is in the right location. Leave the Package field blank and select Finish. \r\n\t\t\t\t\t\t.\r\n\t\t\t\t\t\t\tLook in the Package Explorer view and you will see an icon of your new file inside the src folder, which Eclipse created when you made the new project before. \r\n\t\t\t\t\t\t.\r\n\t\t\t\t\t\t\tThe file should be opened in the open space in the center of the workspace-the \r\n\t\t\t\t\t\t\t.\r\n\t\t\t\t\t\t\tview. (If not, right click on the greeting.py icon and select Open.) You will see a tab with the name of your file. \r\n\t\t\t\t\t\t.\r\n\t\t\t\t\t\t\tHere's a program to greet the world. Simply type \r\n\t\t\t\t\t\t\t.\r\n\t\t\t\t\t\t\tinto the file. \r\n\t\t\t\t\t\t\tYou may remove the default doc comment or leave it \r\n\t\t\t\t\t\t\tthere; Python ignores it..\r\n\t\t\t\t\t\t\tRight click on the file and select Save (or press Ctrl+S) to save the file. \r\n\t\t\t\t\t\t.\r\n\t\t\t\t\t\t\t(A quicker alternative is to right-click on the \r\n\t\t\t\t\t\t\tgreeting.py icon, and select ., \r\n\t\t\t\t\t\t\tor press Ctrl+F11.) \r\n\t\t\t\t\t\t.\r\n\t\t\t\t\t\t\tLook at the bottom of your screen at the \r\n\t\t\t\t\t\t\t.\r\n\t\t\t\t\t\t\tview and you will see the message you told the computer to print. \r\n\t\t\t\t\t\t.\r\n\t\t\t\t\t\t\tCongratulations! You have written your first program with Python. \r\n\t\t\t\t\t\t.\n",
        "Originally, Sphinx was conceived for a single project, the documentation of the\nPython language.  Shortly afterwards, it was made available for everyone as a\ndocumentation tool, but the documentation of Python modules remained deeply\nbuilt in – the most fundamental directives, like ., were designed\nfor Python objects.  Since Sphinx has become somewhat popular, interest\ndeveloped in using it for many different purposes: C/C++ projects, JavaScript,\nor even reStructuredText markup (like in this documentation)..While this was always possible, it is now much easier to easily support\ndocumentation of projects using different programming languages or even ones\nnot supported by the main Sphinx distribution, by providing a . for\nevery such purpose..A domain is a collection of markup (reStructuredText .s and\n.s) to describe and link to .s belonging together,\ne.g. elements of a programming language.  Directive and role names in a domain\nhave names like ., e.g. ..  Domains can also\nprovide custom indices (like the Python Module Index)..Having domains means that there are no naming problems when one set of\ndocumentation wants to refer to e.g. C++ and Python classes.  It also means\nthat extensions that support the documentation of whole new languages are much\neasier to write..This section describes what the domains that are included with Sphinx provide.\nThe domain API is documented as well, in the section ...Most domains provide a number of ., used to\ndescribe specific objects provided by modules.  Each directive requires one or\nmore signatures to provide basic information about what is being described, and\nthe content should be the description.  A domain will typically keep an\ninternal index of all entities to aid cross-referencing. Typically it will\nalso add entries in the shown general index.\nIf you want to suppress the addition of an entry in the shown index, you can\ngive the directive option flag ..\nIf you want to typeset an object description, without even making it available\nfor cross-referencing, you can give the directive option flag .\n(which implies .).\nThough, note that not every directive in every domain may support these\noptions..The directive option . in the Python, C, C++, and Javascript\ndomains..An example using a Python domain directive:.This describes the two Python functions . and ..  (Note that when\nsignatures become too long, you can break them if you add a backslash to lines\nthat are continued in the next line.  Example:.(This example also shows how to use the . flag.).The domains also provide roles that link back to these object descriptions.\nFor example, to link to one of the functions described in the example above,\nyou could say.As you can see, both directive and role names contain the domain name and the\ndirective name..Default Domain.For documentation describing objects from solely one domain, authors will not\nhave to state again its name at each directive, role, etc… after\nhaving specified a default. This can be done either via the config\nvalue . or via this directive:.Select a new default domain.  While the . selects a\nglobal default, this only has an effect within the same file..If no other default is selected, the Python domain (named .) is the\ndefault one, mostly for compatibility with documentation written for older\nversions of Sphinx..Directives and roles that belong to the default domain can be mentioned without\ngiving the domain name, i.e..For cross-reference roles provided by domains, the same facilities exist as for\ngeneral cross-references.  See ...In short:.You may supply an explicit title and reference target: . will refer to ., but the link text will be ...If you prefix the content with ., no reference/hyperlink will be created..If you prefix the content with ., the link text will only be the last\ncomponent of the target.  For example, . will\nrefer to . but only display . as the link text..The Python domain (name .) provides the following directives for module\ndeclarations:.This directive marks the beginning of the description of a module (or package\nsubmodule, in which case the name should be fully qualified, including the\npackage name).  It does not create content (like e.g. .\ndoes)..This directive will also cause an entry in the global module index..options.Indicate platforms which the module is available (if it is available on\nall platforms, the option should be omitted).  The keys are short\nidentifiers; examples that are in use include “IRIX”, “Mac”, “Windows”\nand “Unix”.  It is important to use a key which has already been used when\napplicable..Consist of one sentence describing the module’s purpose – it is currently\nonly used in the Global Module Index..Mark a module as deprecated; it will be designated as such in various\nlocations then..This directive tells Sphinx that the classes, functions etc. documented from\nhere are in the given module (like .), but it will not\ncreate index entries, an entry in the Global Module Index, or a link target\nfor ..  This is helpful in situations where documentation\nfor things in a module is spread over multiple files or sections – one\nlocation has the . directive, the others only\n...The following directives are provided for module and class contents:.Describes a module-level function.  The signature should include the\nparameters as given in the Python function definition, see ..\nFor example:.For methods you should use ...The description normally includes information about the parameters required\nand how they are used (especially whether mutable objects passed as\nparameters are modified), side effects, and possible exceptions..This information can (in any . directive) optionally be given in a\nstructured form, see ...options.Indicate the function is an async function..Describe the location where the object is defined if the object is\nimported from other modules.Describes global data in a module, including both variables and values used\nas “defined constants.”  Class and object attributes are not documented\nusing this environment..options.Describe the location where the object is defined if the object is\nimported from other modules.Describes an exception class.  The signature can, but need not include\nparentheses with constructor arguments..options.Indicate the class is a final class..Describes a class.  The signature can optionally include parentheses with\nparameters which will be shown as the constructor arguments.  See also\n...Methods and attributes belonging to the class should be placed in this\ndirective’s body.  If they are placed outside, the supplied name should\ncontain the class name so that cross-references still work.  Example:.The first way is the preferred one..options.Describe the location where the object is defined if the object is\nimported from other modules.Indicate the class is a final class..Describes an object data attribute.  The description should include\ninformation about the type of the data to be expected and whether it may be\nchanged directly..options.Describe the location where the object is defined if the object is\nimported from other modules.Describes an object property..options.Indicate the property is abstract..Indicate the property is a classmethod..Describes an object method.  The parameters should not include the .\nparameter.  The description should include similar information to that\ndescribed for ..  See also . and\n...options.Indicate the method is an abstract method..Indicate the method is an async method..Describe the location where the object is defined if the object is\nimported from other modules.Indicate the method is a class method..Indicate the class is a final method..Indicate the method is a property..Use . instead..Indicate the method is a static method..Like ., but indicates that the method is a static method..Like ., but indicates that the method is a class method..Describes a decorator function.  The signature should represent the usage as\na decorator.  For example, given the functions.the descriptions should look like this:.(as opposed to ..).There is no . role to link to a decorator that is marked up with\nthis directive; rather, use the . role..Same as ., but for decorators that are methods..Refer to a decorator method using the . role..Signatures of functions, methods and class constructors can be given like they\nwould be written in Python..Default values for optional arguments can be given (but if they contain commas,\nthey will confuse the signature parser).  Python 3-style argument annotations\ncan also be given as well as return type annotations:.For functions with optional parameters that don’t have default values\n(typically functions implemented in C extension modules without keyword\nargument support), you can use brackets to specify the optional parts:.It is customary to put the opening bracket before the comma..meta fields are added..Inside Python object description directives, reST field lists with these fields\nare recognized and formatted nicely:., ., ., ., ., .:\nDescription of a parameter..: Type of a parameter.  Creates a link if possible.., ., ., .: That (and when) a specific\nexception is raised.., ., .: Description of a variable..: Type of a variable.  Creates a link if possible.., .: Description of the return value..: Return type.  Creates a link if possible..: Add metadata to description of the python object.  The metadata will\nnot be shown on output document.  For example, . indicates\nthe python object is private member.  It is used in\n. for filtering members..Note.In current release, all ., . and . are represented as\n“Variable”.  There is no difference at all..The field names must consist of one of these keywords and an argument (except\nfor . and ., which do not need an argument).  This is best\nexplained by an example:.This will render like this:.Send a message to a recipient. (.) – The person sending the message. (.) – The recipient of the message. (.) – The body of the message. (.) – The priority of the message, can be a number 1-5.the message id. – if the message_body exceeds 160 characters. – if the message_body is not a basestring.It is also possible to combine parameter type and description, if the type is a\nsingle word, like this:.Container types such as lists and dictionaries can be linked automatically\nusing the following syntax:.Multiple types in a type field will be linked automatically if separated by the\nword “or”:.The following roles refer to objects in modules and are possibly hyperlinked if\na matching identifier is found:.Reference a module; a dotted name may be used.  This should also be used for\npackage names..Reference a Python function; dotted names may be used.  The role text needs\nnot include trailing parentheses to enhance readability; they will be added\nautomatically by Sphinx if the . config\nvalue is . (the default)..Reference a module-level variable..Reference a “defined” constant.  This may be a Python variable that is not\nintended to be changed..Reference a class; a dotted name may be used..Reference a method of an object.  The role text can include the type name\nand the method name; if it occurs within the description of a type, the type\nname can be omitted.  A dotted name may be used..Reference a data attribute of an object..Note.The role is also able to refer to property..Reference an exception.  A dotted name may be used..Reference an object of unspecified type.  Useful e.g. as the\n...The name enclosed in this markup can include a module name and/or a class name.\nFor example, . could refer to a function named .\nin the current module, or the built-in function of that name.  In contrast,\n. clearly refers to the . function in the\n. module..Normally, names in these roles are searched first without any further\nqualification, then with the current module name prepended, then with the\ncurrent module and class name (if any) prepended.  If you prefix the name with\na dot, this order is reversed.  For example, in the documentation of Python’s\n. module, . always refers to the built-in\nfunction, while . refers to ...A similar heuristic is used to determine whether the name is an attribute of\nthe currently documented class..Also, if the name is prefixed with a dot, and no exact match is found, the\ntarget is taken as a suffix and all object names with that suffix are searched.\nFor example, . references the\n. function, even if the current module is not\n..  Since this can get ambiguous, if there is more than one possible\nmatch, you will get a warning from Sphinx..Note that you can combine the . and . prefixes:\n. will reference the .\nmethod, but the visible link caption will only be ...The C domain (name .) is suited for documentation of C API..Describes a C struct member or variable. Example signature:.The difference between the two directives is only cosmetic..Describes a C function. The signature should be given as in C, e.g.:.Note that you don’t have to backslash-escape asterisks in the signature, as\nit is not parsed by the reST inliner..In the description of a function you can use the following info fields\n(see also .).., ., ., .,\nDescription of a parameter..: Type of a parameter,\nwritten as if passed to the . role.., .: Description of the return value..: Return type,\nwritten as if passed to the . role.., .: An alternative to . for describing\nthe result of the function..The . field type..For example:.which renders as. – description of the first parameter.. – description of the second parameter..a result.. – under some conditions.. – under some other conditions as well..Describes a C macro, i.e., a C-language ., without the replacement\ntext..In the description of a macro you can use the same info fields as for the\n. directive..The function style variant..Describes a C struct..Describes a C union..Describes a C enum..Describes a C enumerator..Describes a C type, either as a typedef, or the alias for an unspecified\ntype..The following roles create cross-references to C-language constructs if they\nare defined in the documentation:.Reference a C declaration, as defined above.\nNote that ., ., and\n. are equivalent..The var, struct, union, enum, and enumerator roles..C supports anonymous structs, enums, and unions.\nFor the sake of documentation they must be given some name that starts with\n., e.g., . or ..\nThese names can also be used in cross-references,\nthough nested symbols will be found even when omitted.\nThe . name will always be rendered as . (possibly as a\nlink)..Example:.This will be rendered as:.Explicit ref: .. Short-hand ref: ...Sometimes it may be helpful list declarations elsewhere than their main\ndocumentation, e.g., when creating a synopsis of an interface.\nThe following directive can be used for this purpose..Insert one or more alias declarations. Each entity can be specified\nas they can in the . role..For example:.becomes.Options.Insert nested declarations as well, up to the total depth given.\nUse 0 for infinite depth and 1 for just the mentioned declaration.\nDefaults to 1..Skip the mentioned declarations and only render nested declarations.\nRequires . either 0 or at least 2..Insert a C expression or type either as inline code (.)\nor inline text (.). For example:.will be rendered as follows:.An expression: . (or as text: .)..A type: .\n(or as text .)..The C language it self does not support namespacing, but it can sometimes be\nuseful to emulate it in documentation, e.g., to show alternate declarations.\nThe feature may also be used to document members of structs/unions/enums\nseparate from their parent declaration..The current scope can be changed using three namespace directives.  They manage\na stack declarations where . resets the stack and changes a given\nscope..The . directive changes the scope to a given inner scope\nof the current one..The . directive undoes the most recent\n. directive..Changes the current scope for the subsequent objects to the given scope, and\nresets the namespace directive stack. Note that nested scopes can be\nspecified by separating with a dot, e.g.:.All subsequent objects will be defined as if their name were declared with\nthe scope prepended. The subsequent cross-references will be searched for\nstarting in the current scope..Using . or . as the scope will change to global scope..Change the scope relatively to the current scope. For example, after:.the current scope will be ...Undo the previous . directive (. just pop a scope).\nFor example, after:.the current scope will be . (. .)..If no previous . directive has been used, but only a\n. directive, then the current scope will be reset to global\nscope.  That is, . is equivalent to:.See ...The C++ domain (name .) supports documenting C++ projects..The following directives are available. All declarations can start with a\nvisibility statement (., . or .)..Describe a class/struct, possibly with specification of inheritance, e.g.,:.The difference between . and . is\nonly cosmetic: the prefix rendered in the output, and the specifier shown\nin the index..The class can be directly declared inside a nested scope, e.g.,:.A class template can be declared:.or with a line break:.Full and partial template specialisations can be declared:.The . directive..Describe a function or member function, e.g.,:.Function templates can also be described:.and function template specialisations:.Describe a variable or member variable, e.g.,:.Variable templates can also be described:.Describe a type as in a typedef declaration, a type alias declaration, or\nsimply the name of a type with unspecified type, e.g.,:.A type alias can also be templated:.The example are rendered as follows..A typedef-like declaration of a type..Declaration of a type alias with unspecified type..Declaration of a type alias..Describe a (scoped) enum, possibly with the underlying type specified.  Any\nenumerators declared inside an unscoped enum will be declared both in the\nenum scope and in the parent scope.  Examples:.Describe an enumerator, optionally with its value defined, e.g.,:.Describe a union..Warning.The support for concepts is experimental. It is based on the\ncurrent draft standard and the Concepts Technical Specification.\nThe features may change as they evolve..Describe a concept. It must have exactly 1 template parameter list. The name\nmay be a nested name. Example:.This will render as follows:.Proxy to an element of a notional sequence that can be compared,\nindirected, or incremented..An lvalue.., when . is dereferenceable.., with return type ., when .\nis incrementable..Some directives support options:., see ..., for templated declarations.\nIf specified, each template parameter will be rendered on a separate line..C++ supports anonymous namespaces, classes, enums, and unions.\nFor the sake of documentation they must be given some name that starts with\n., e.g., . or ..\nThese names can also be used in cross-references and (type) expressions,\nthough nested symbols will be found even when omitted.\nThe . name will always be rendered as . (possibly as a\nlink)..Example:.This will be rendered as:.Explicit ref: .. Short-hand ref: ...Sometimes it may be helpful list declarations elsewhere than their main\ndocumentation, e.g., when creating a synopsis of a class interface.\nThe following directive can be used for this purpose..Insert one or more alias declarations. Each entity can be specified\nas they can in the . role.\nIf the name of a function is given (as opposed to the complete signature),\nthen all overloads of the function will be listed..For example:.becomes.whereas:.becomes.Options.Insert nested declarations as well, up to the total depth given.\nUse 0 for infinite depth and 1 for just the mentioned declaration.\nDefaults to 1..Skip the mentioned declarations and only render nested declarations.\nRequires . either 0 or at least 2..Warning.The support for concepts is experimental. It is based on the\ncurrent draft standard and the Concepts Technical Specification.\nThe features may change as they evolve..Note.Sphinx does not currently support . clauses..Declarations may use the name of a concept to introduce constrained template\nparameters, or the keyword . to introduce unconstrained template\nparameters:.Simple constrained function or class templates can be declared with a . instead of a template parameter list:.They are rendered as follows..A function template with a template parameter constrained to be an Iterator..A class template with a template parameter constrained to be\nLessThanComparable..Note however that no checking is performed with respect to parameter\ncompatibility. E.g., . will be accepted as an introduction\neven though it would not be valid C++..Insert a C++ expression or type either as inline code (.)\nor inline text (.). For example:.will be rendered as follows:.An expression: . (or as text: .)..A type: .\n(or as text .)..The . role..The . role..Declarations in the C++ domain are as default placed in global scope.  The\ncurrent scope can be changed using three namespace directives.  They manage a\nstack declarations where . resets the stack and changes a given\nscope..The . directive changes the scope to a given inner scope\nof the current one..The . directive undoes the most recent\n. directive..Changes the current scope for the subsequent objects to the given scope, and\nresets the namespace directive stack.  Note that the namespace does not need\nto correspond to C++ namespaces, but can end in names of classes, e.g.,:.All subsequent objects will be defined as if their name were declared with\nthe scope prepended. The subsequent cross-references will be searched for\nstarting in the current scope..Using ., ., or . as the scope will change to global\nscope..A namespace declaration can also be templated, e.g.,:.declares . as a member function of the class template\n..  Equivalently this could have been declared using:.or:.Change the scope relatively to the current scope. For example, after:.the current scope will be ...Undo the previous . directive (. just pop a scope).\nFor example, after:.the current scope will be . (. .)..If no previous . directive has been used, but only a\n. directive, then the current scope will be reset to global\nscope.  That is, . is equivalent to:.All the C++ directives for declaring entities support the following\ninfo fields (see also .):.: Description of a template parameter..The . directive additionally supports the\nfollowing fields:., ., ., .: Description of a parameter.., .: Description of a return value.., .: An alternative to . for describing\nthe result of the function.., ., .: Description of a possibly thrown exception..The . field type..These roles link to the given declaration types:.Reference a C++ declaration by name (see below for details).  The name must\nbe properly qualified relative to the position of the link..The . role as alias for the .\nrole..Note on References with Templates Parameters/Arguments.These roles follow the Sphinx . rules. This means care must\nbe taken when referencing a (partial) template specialization, e.g. if the\nlink looks like this: ..\nThis is interpreted as a link to . with a title of ..\nIn this case, escape the opening angle bracket with a backslash,\nlike this: ...When a custom title is not needed it may be useful to use the roles for\ninline expressions, . and ., where\nangle brackets do not need escaping..For linking to non-templated declarations the name must be a nested name, e.g.,\n. or ...When a (member) function is referenced using just its name, the reference\nwill point to an arbitrary matching overload.\nThe . and . roles use an alternative\nformat, which simply is a complete function declaration.\nThis will resolve to the exact matching overload.\nAs example, consider the following class declaration:.References using the . role:.Arbitrary overload: ., .Also arbitrary overload: ., .Specific overload: ., .Specific overload: ., .Specific overload: ., .Specific overload: .,\n.Note that the . configuration variable\ndoes not influence specific overload references..Assume the following declarations..In general the reference must include the template parameter declarations,\nand template arguments for the prefix of qualified names. For example:.\n(.).\n(.).Currently the lookup only succeed if the template parameter identifiers are\nequal strings.  That is, . will not\nwork..As a shorthand notation, if a template parameter list is omitted,\nthen the lookup will assume either a primary template or a non-template,\nbut not a partial template specialisation.\nThis means the following references work as well:.\n(.).\n(.).\n(.).Assume the following declarations..In general the reference must include a template parameter list for each\ntemplate argument list.  The full specialisation above can therefore be\nreferenced with . (.) and .\n(.).  As a\nshorthand the empty template parameter list can be omitted, e.g.,\n. (.) and .\n(.)..Assume the following declaration..References to partial specialisations must always include the template\nparameter lists, e.g., .\n(.).  Currently the lookup only\nsucceed if the template parameter identifiers are equal strings..See ...The so-called “standard” domain collects all markup that doesn’t warrant a\ndomain of its own.  Its directives and roles are not prefixed with a domain\nname..The standard domain is also where custom object descriptions, added using the\n. API, are placed..There is a set of directives allowing documenting command-line programs:.Describes a command line argument or switch.  Option argument names should\nbe enclosed in angle brackets.  Examples:.The directive will create cross-reference targets for the given options,\nreferenceable by . (in the example case, you’d use something\nlike ., ., or .).. directive is a deprecated alias for the . directive..Describes an environment variable that the documented code or program uses\nor defines.  Referenceable by ...Like ., this directive produces no output.\nInstead, it serves to notify Sphinx that all following .\ndirectives document options for the program called ...If you use ., you have to qualify the references in your\n. roles by the program name, so if you have the following\nsituation.then . would refer to the first option, while\n. would refer to the second one..If . is passed to the argument, the directive will reset the\ncurrent program name..The program name may contain spaces (in case you want to document\nsubcommands like . and . separately)..There is also a very generic object description directive, which is not tied to\nany domain:.This directive produces the same formatting as the specific ones provided by\ndomains, but does not create index entries or cross-referencing targets.\nExample:.The JavaScript domain (name .) provides the following directives:.This directive sets the module name for object declarations that follow\nafter. The module name is used in the global module index and in cross\nreferences. This directive does not create an object heading like\n. would, for example..By default, this directive will create a linkable entity and will cause an\nentry in the global module index, unless the . option is\nspecified.  If this option is specified, the directive will only update the\ncurrent module name..Describes a JavaScript function or method.  If you want to describe\narguments as optional use square brackets as .\nfor Python signatures..You can use fields to give more details about arguments and their expected\ntypes, errors which may be thrown by the function, and the value being\nreturned:.This is rendered as:. (.) – An URI to the location of the resource.. – Gets called with the object.. – Gets called in case the request fails. And a lot of other\ntext so we need multiple lines.. – For whatever reason in that case..Something..This directive is an alias for ., however it describes\na function that is implemented as a method on a class object..Describes a constructor that creates an object.  This is basically like a\nfunction but will show up with a . prefix:.This is rendered as:. (.) – The name of the animal. (.) – an optional age for the animal.Describes a global variable or constant..Describes the attribute . of ...These roles are provided to refer to the described objects:.The reStructuredText domain (name .) provides the following directives:.Describes a reST directive.  The . can be a single directive name or\nactual directive syntax (. prefix and . suffix) with arguments that\nwill be rendered differently.  For example:.will be rendered as:.Foo description..Bar description..Describes an option for reST directive.  The . can be a single option\nname or option name with arguments which separated with colon (.).\nFor example:.will be rendered as:.options.Describe the type of option value..For example:.Describes a reST role.  For example:.will be rendered as:.Foo description..These roles are provided to refer to the described objects:.The math domain (name .) provides the following roles:.Role for cross-referencing equations defined by . directive\nvia their label.  Example:.The . repository contains more domains available as extensions;\ncurrently ., ., ., ., ., ., ., and .\ndomains. Also available are domains for ., ., ., .,\n., ., and ..",
        "",
        "",
        "In Python, a generator is a function that returns an iterator object. There are a couple of ways to do this, but the most elegant and common one is to use the . statement..For example, here is a simple synthetic example:.The . function is a generator. Given any sequence, it returns an iterator that yields the sequences's elements in reversed order, and also enumerates them. For example:.The goal of this post is to demonstrate how to achieve the same effect using the Python C API; in other words, in a C extension module. The focus is on Python 3 - for Python 2 the principle is the same although there may be some differences in the details.. is a very powerful construct in Python. In C there is no equivalent ability (unless you use some co-routine macro-fu, but this is outside our scope here). Therefore, we have to explicitly return an iterator object and let it handle the details of the iteration..To write . in Python we have to create a class that implements the . and . special methods. The equivalent methods in the C API are . and ., respectively..We'll create a new extension module, named .. It will export a single object - the . type which will be callable similarly to the Python code above. In other words, the client Python code will be able to do:.Let's begin (a link to the full source code is available at the end of this post):.This is standard code for creating a new module and a new type in it. The module initialization function (.) adds a single object to the module, named .. This object is the . type. By \"calling\" this object, the user is able to create new instances of the type..The following structure (\"subclass\" of .) is going to represent an instance of .:.The most interesting thing to note here is the reference to the sequence we're iterating on. The iterator needs this instance to be able to access the sequence each time . is called on it..And here is the function responsible for creating new instances. It is assigned to the . slot of the type. Note that we don't assign ., so the default \"do-nothing\" initializer will be used:.This is a straightforward . implementation. It makes sure the object it's expected to iterate on is a sequence, and initializes the state to prepare returning the last element in the first . call. The corresponding de-allocation function is also unsurprising:.Now what's left to see is the implementations of the . and . slots. Since our type is an iterator, it can just assign . function for the . slot. . is where the interesting work is happening. This is what gets invoked when the . built-in is called on the iterator, and by extension also when the iterator is consumed by a . loop:.The most important point to remember here is this - the state of the iteration should be wholly kept in the iterator object. Comparing to the Python implementation, this means quite a bit more work. The Python . statement allows us to use the Python interpreter itself to keep the state of execution for us. This is what makes . - very little explicit state has to be kept manually. As I mentioned in the beginning of the post, in C extensions we don't have this luxury, so we have to go the manual way. Since the current example is very simple and linear, this is relatively easy. In more complex examples, some ingenuity is often required to design the state object and . function correctly..The full code of this post, together with a simple Python test script and a . for building the extension with distutils is .\nFor comments, please send me\n..\n",
        "",
        "arXivLabs is a framework that allows collaborators to develop and share new arXiv features directly on our website..Both individuals and organizations that work with arXivLabs have embraced and accepted our values of openness, community, excellence, and user data privacy. arXiv is committed to these values and only works with partners that adhere to them..Have an idea for a project that will add value for arXiv's community? . and ..",
        "",
        "",
        "The payloads are compatible with both Python version 2 and 3..It can be used to break out from restricted environments by spawning an interactive system shell..It can send back a reverse shell to a listening attacker to open a remote network access..Run . on the attacker box to receive the shell..It can exfiltrate files on the network..Send local file via “d” parameter of a HTTP POST request. Run an HTTP service on the attacker box to collect the file..Serve files in the local folder running an HTTP server..It can download remote files..Fetch a remote file via HTTP GET request..It writes data to files, it may be used to do privileged writes or write files outside a restricted file system..It reads data from files, it may be used to do privileged reads or disclose files outside a restricted file system..It loads shared libraries that may be used to run code in the binary execution context..If the binary has the SUID bit set, it does not drop the elevated privileges and may be abused to access the file system, escalate or maintain privileged access as a SUID backdoor. If it is used to run ., omit the . argument on systems like Debian (<= Stretch) that allow the default . shell to run with SUID privileges..This example creates a local SUID copy of the binary and runs it to maintain elevated privileges. To interact with an existing SUID binary skip the first command and run the program using its original path..If the binary is allowed to run as superuser by ., it does not drop the elevated privileges and may be used to access the file system, escalate or maintain privileged access..If the binary has the Linux . capability set or it is executed by another binary with the capability set, it can be used as a backdoor to maintain privileged access by manipulating its own process UID.",
        "© 2021 Vinayak Mehta..\n.\n        Want to become a better programmer?\n        .\n.Today I spent most of my time watching some talks on writing Python C extensions. Every talk mentioned that the main reasons for writing an extension are:.I need to try and write some code to talk to one of the large C/C++ projects I mentioned in . instead of procrastinating by watching talks :(.I learned a lot from these talks by Paul Ross:.He talks about various gotchas we should keep in mind while using Python's C API. There's three types of references when we interact with .s:.When we create a new ., it's our job to deallocate it by decrementing its reference count!.He shows the function above which subtracts two long integers. And talks about using . to decrement reference counts for the new .s (. and .) we create in the function, after we've used them..We should not try to be \"Pythonic\" and do something like above (without the appropriate . calls) because that's how we get memory leaks!.When we create a new ., but it gets stolen, it's the \"thief\"'s job to deallocate it..In the example above, we create a new . called . which gets stolen by . (a tuple) when we assign . as its first element. In this case, we don't need to use . to decrement .'s reference count..This is a big no-no! And will result in bugs because Python's garbage collector might deallocate . before . has had a chance to process it!.When we borrow a reference to a ., the real owner can deallocate it at any time, unless we prevent them by registering our interest!.In the above example, we create a new . called ., and make it point to the first element of .. But what happens when we pass . into a function that removes the first element of the list? What is . going to point to?.Paul Ross shows that this function actually causes a seg fault when we try to call it from the Python REPL!.The fix is to increase the reference count for . when we create it, decrease it after we've used it, and then set it to . so we don't accidentally use it later (if there's a lot of other code below .)..He also describes a pattern to write reliable C when we're interacting with Python's C API, where he shows how we can write Pythonic C (similar to Python's try-except-finally!) using . statements:.We should also:.He has written about this in a lot more detail at ...This talk is a survey of various tools that can help us write Python C extensions. Paul Ross shows some tradeoffs that we should keep in mind while choosing a tool. And he also mentions that we should structure our code like this so that it's easier to test the Python and C code separately, because testing glue code can be cumbersome.",
        "",
        "\n.\n\tCorporation for National Research Initiatives \n.\n1895 Preston White Drive, Reston, VA 20191, USA \n.\nE-mail: .\n.\n.\n.\n.\n.Table of Child-Links.\n.\n.End of Table of Child-Links.\n.\n.\n.End of Navigation Panel.\n.\n",
        "Often during pen tests you may obtain a shell without having tty, yet wish to interact further with the system. Here are some commands which will allow you to spawn a tty shell. Obviously some of this will depend on the system environment and installed packages..\n.python -c 'import pty; pty.spawn(\"/bin/sh\")'.echo os.system('/bin/bash')./bin/sh -i.perl —e 'exec \"/bin/sh\";'.perl: exec \"/bin/sh\";.ruby: exec \"/bin/sh\".lua: os.execute('/bin/sh').exec \"/bin/sh\".:!bash.:set shell=/bin/bash:shell.!sh.Many of these will also allow you to escape jail shells. The top 3 would be my most successful in general for spawning from the command line.",
        "",
        " (pronounced . (.) or sometimes . (.)) is a . for the ., adding support for large, multi-dimensional . and ., along with a large collection of . . . to operate on these arrays.. The ancestor of NumPy, Numeric, was originally created by . with contributions from several other developers. In 2005, . created NumPy by incorporating features of the competing Numarray into Numeric, with extensive modifications. NumPy is . and has many contributors. NumPy is a . fiscally sponsored project..\n.The Python programming language was not originally designed for numerical computing, but attracted the attention of the scientific and engineering community early on. In 1995 the . (SIG) . was founded with the aim of defining an . computing package; among its members was Python designer and maintainer ., who extended . (in particular the indexing syntax.) to make . easier..\n.An implementation of a matrix package was completed by Jim Fulton, then generalized. by Jim Hugunin and called . (also variously known as the \"Numerical Python extensions\" or \"NumPy\")..\nHugunin, a graduate student at the . (MIT),. joined the . (CNRI) in 1997 to work on .,. leaving Paul Dubois of . (LLNL) to take over as maintainer.. Other early contributors include David Ascher, Konrad Hinsen and ...\n.A new package called . was written as a more flexible replacement for Numeric.. Like Numeric, it too is now deprecated.. Numarray had faster operations for large arrays, but was slower than Numeric on small ones,. so for a time both packages were used in parallel for different use cases. The last version of Numeric (v24.2) was released on 11 November 2005, while the last version of numarray (v1.5.2) was released on 24 August 2006..\n.There was a desire to get Numeric into the Python standard library, but Guido van Rossum decided that the code was not maintainable in its state then..\n.In early 2005, NumPy developer Travis Oliphant wanted to unify the community around a single array package and ported Numarray's features to Numeric, releasing the result as NumPy 1.0 in 2006.. This new project was part of .. To avoid installing the large SciPy package just to get an array object, this new package was separated and called NumPy. Support for Python 3 was added in 2011 with NumPy version 1.5.0..\n.In 2011, . started development on an implementation of the NumPy API for PyPy.. It is not yet fully compatible with NumPy..\n.NumPy targets the . . of Python, which is a non-optimizing . .. . written for this version of Python often run much slower than . equivalents. NumPy addresses the slowness problem partly by providing multidimensional arrays and functions and operators that operate efficiently on arrays; using these requires rewriting some code, mostly ., using NumPy.\n.Using NumPy in Python gives functionality comparable to . since they are both interpreted,. and they both allow the user to write fast programs as long as most operations work on . or matrices instead of .. In comparison, MATLAB boasts a large number of additional toolboxes, notably ., whereas NumPy is intrinsically integrated with Python, a more modern and complete .. Moreover, complementary Python packages are available; SciPy is a library that adds more MATLAB-like functionality and . is a . package that provides MATLAB-like plotting functionality. Internally, both MATLAB and NumPy rely on . and . for efficient . computations.\n.Python . of the widely used . library . utilize NumPy arrays to store and operate on data.\nSince images with multiple channels are simply represented as three-dimensional arrays, indexing, . or . with other arrays are very efficient ways to access specific pixels of an image.\nThe NumPy array as universal data structure in OpenCV for images, extracted ., . and many more vastly simplifies the programming workflow and ..\n.The core functionality of NumPy is its \"ndarray\", for .-dimensional array, data structure. These arrays are . views on memory.. In contrast to Python's built-in list data structure, these arrays are homogeneously typed: all elements of a single array must be of the same type.\n.Such arrays can also be views into memory buffers allocated by ./., ., and . extensions to the CPython interpreter without the need to copy data around, giving a degree of compatibility with existing numerical libraries. This functionality is exploited by the SciPy package, which wraps a number of such libraries (notably BLAS and LAPACK). NumPy has built-in support for . ndarrays..\n.Inserting or appending entries to an array is not as trivially possible as it is with Python's lists.\nThe . routine to extend arrays actually creates new arrays of the desired shape and padding values, copies the given array into the new one and returns it.\nNumPy's . operation does not actually link the two arrays but returns a new one, filled with the entries from both given arrays in sequence.\nReshaping the dimensionality of an array with . is only possible as long as the number of elements in the array does not change.\nThese circumstances originate from the fact that NumPy's arrays must be views on contiguous .. A replacement package called Blaze attempts to overcome this limitation..\n. that are not expressible as a vectorized operation will typically run slowly because they must be implemented in \"pure Python\", while vectorization may increase . of some operations from constant to linear, because temporary arrays must be created that are as large as the inputs. Runtime compilation of numerical code has been implemented by several groups to avoid these problems; open source solutions that interoperate with NumPy include ., numexpr. and ... Cython and . are static-compiling alternatives to these.\n.Many modern . scientific computing applications have requirements that exceed the capabilities of the NumPy arrays.\nFor example, NumPy arrays are usually loaded into a computer's ., which might have insufficient capacity for the analysis of large ..\nFurther, NumPy operations are executed on a single ..\nHowever, many linear algebra operations can be accelerated by executing them on . of CPUs or of specialized hardware, such as . and ., which many . applications rely on.\nAs a result, several alternative array implementations have arisen in the scientific python ecosystem over the recent years, such as . for distributed arrays and . or . for computations on GPUs.\nBecause of its popularity, these often implement a . of Numpy's . or mimic it, so that users can change their array implementation with minimal changes to their code required.. A recently introduced library named .,. accelerated by .'s . framework, has also shown potential for faster computing, being a '.' of NumPy..\n.Iterative Python algorithm and vectorized NumPy version.\n",
        "\n            Please . if you use the software.\n          .There are different ways to install scikit-learn:.. This\nis the best approach for most users. It will provide a stable version\nand pre-built packages are available for most platforms..Install the version of scikit-learn provided by your\n..\nThis is a quick option for those who have operating systems or Python\ndistributions that distribute scikit-learn.\nIt might not provide the latest release version... This is best for users who want the\nlatest-and-greatest features and aren’t afraid of running\nbrand-new code. This is also needed for users who wish to contribute to the\nproject..Then run:.In order to check your installation you can use.Note that in order to avoid potential conflicts with other packages it is\nstrongly recommended to use a . or a ...Using such an isolated environment makes it possible to install a specific\nversion of scikit-learn with pip or conda and its dependencies independently of\nany previously installed Python packages. In particular under Linux is it\ndiscouraged to install pip packages alongside the packages managed by the\npackage manager of the distribution (apt, dnf, pacman…)..Note that you should always remember to activate the environment of your choice\nprior to running any Python command whenever you start a new terminal session..If you have not installed NumPy or SciPy yet, you can also install these using\nconda or pip. When using pip, please ensure that . are used,\nand NumPy and SciPy are not recompiled from source, which can happen when using\nparticular configurations of operating system and hardware (such as Linux on\na Raspberry Pi)..Scikit-learn plotting capabilities (i.e., functions start with “plot_”\nand classes end with “Display”) require Matplotlib. The examples require\nMatplotlib and some examples require scikit-image, pandas, or seaborn. The\nminimum version of Scikit-learn dependencies are listed below along with its\npurpose..Dependency.Minimum Version.Purpose.numpy.1.14.6.build, install.scipy.1.1.0.build, install.joblib.0.11.install.threadpoolctl.2.0.0.install.cython.0.28.5.build.matplotlib.2.2.3.benchmark, docs, examples, tests.scikit-image.0.14.5.docs, examples, tests.pandas.0.25.0.benchmark, docs, examples, tests.seaborn.0.9.0.docs, examples.memory_profiler.0.57.0.benchmark, docs.pytest.5.0.1.tests.pytest-cov.2.9.0.tests.flake8.3.8.2.tests.black.21.6b0.tests.mypy.0.770.tests.pyamg.4.0.0.tests.sphinx.4.0.1.docs.sphinx-gallery.0.7.0.docs.numpydoc.1.0.0.docs.Pillow.7.1.2.docs.sphinx-prompt.1.3.0.docs.sphinxext-opengraph.0.4.2.docs.Warning.Scikit-learn 0.20 was the last version to support Python 2.7 and Python 3.4.\nScikit-learn 0.21 supported Python 3.5-3.7.\nScikit-learn 0.22 supported Python 3.5-3.8.\nScikit-learn 0.23 - 0.24 require Python 3.6 or newer.\nScikit-learn 1.0 and later requires Python 3.7 or newer..Note.For installing on PyPy, PyPy3-v5.10+, Numpy 1.14.0+, and scipy 1.1.0+\nare required..The recently introduced . platform (sometimes also known as\n.) requires the open source community to upgrade the build\nconfiguration and automation to properly support it..At the time of writing (January 2021), the only way to get a working\ninstallation of scikit-learn on this hardware is to install scikit-learn and its\ndependencies from the conda-forge distribution, for instance using the miniforge\ninstallers:.The following issue tracks progress on making it possible to install\nscikit-learn from PyPI with pip:.Some third-party distributions provide versions of\nscikit-learn integrated with their package-management systems..These can make installation and upgrading much easier for users since\nthe integration includes the ability to automatically install\ndependencies (numpy, scipy) that scikit-learn requires..The following is an incomplete list of OS and python distributions\nthat provide their own version of scikit-learn..Arch Linux’s package is provided through the . as\n. for Python.\nIt can be installed by typing the following command:.The Debian/Ubuntu package is split in three different packages called\n. (python modules), . (low-level\nimplementations and bindings), . (documentation).\nOnly the Python 3 version is available in the Debian Buster (the more recent\nDebian distribution).\nPackages can be installed using .:.The Fedora package is called . for the python 3 version,\nthe only one available in Fedora30.\nIt can be installed using .:.scikit-learn is available via .:.The MacPorts package is named .,\nwhere . denotes the Python version.\nIt can be installed by typing the following\ncommand:. and\n.\nboth ship with scikit-learn in addition to a large set of scientific\npython library for Windows, Mac OSX and Linux..Anaconda offers scikit-learn as part of its free distribution..Intel maintains a dedicated conda channel that ships scikit-learn:.This version of scikit-learn comes with alternative solvers for some common\nestimators. Those solvers come from the DAAL C++ library and are optimized for\nmulti-core Intel CPUs..Note that those solvers are not enabled by default, please refer to the\n. documentation\nfor more details..Compatibility with the standard scikit-learn solvers is checked by running the\nfull scikit-learn test suite via automated continuous integration as reported\non ...The . project distributes\nscikit-learn as an additional plugin..It can happen that pip fails to install packages when reaching the default path\nsize limit of Windows if Python is installed in a nested location such as the\n. folder structure under the user home directory, for instance:.In this case it is possible to lift that limit in the Windows registry by\nusing the . tool:.Type “regedit” in the Windows start menu to launch ...Go to the\n.\nkey..Edit the value of the . property of that key and set\nit to 1..Reinstall scikit-learn (ignoring the previous broken installation):",
        "Get this book in print",
        "\nThe latest update to ., the just-in-time compiling runtime for Python, supplies the usual roster of bug fixes and incremental improvements. Its biggest changes, though, involve a long-standing issue with PyPy’s C extensions and the major Python packages that use them.\n.\nPython has never been the fastest language, but rewriting performance-intensive functions in C can bring Python apps within striking distance of pure C counterparts, often without the headache of writing the app entirely in C.\n.\nPyPy speeds up Python applications by compiling them, but a drawback of the process is that C extensions for Python apps don’t work very well. What’s more, a lot of valuable Python packages use C extensions, and they aren’t going anywhere.\n.\nThe workaround is a compatibility layer with Python’s C API, CPyExt, updated with changes for PyPy 5.6. CPyExt runs the widely used math-and-stats package NumPy, a good example of a major project that needs C extensions, although it still falls short of running Pandas (another math-oriented package in wide use).\n.\nNow the bad news: CPyExt is an emulation layer, so any calls through it are slower. PyPy has two solutions for developers: Either write everything in pure Python and let PyPy speed it up, or use CFFI, a C interface that integrates directly with PyPy.\n.\nThe first option is fine for programs that aren’t heavily dependent on C for functionality or speed. Some Python apps offer the ability to use C modules for acceleration (compiled through tools like .), but can fall back to pure Python if C modules can’t be put to work. For projects like NumPy, it’ll likely be a no-go.\n.\nThe latter, using CFFI, has issues too. CFFI uses a more “Pythonic” metaphor for working with C than Python’s native ctypes interface, but the two aren’t interchangeable. Existing Python packages that interface with C in the standard manner won't likely be rewritten to use CFFI for PyPy compatibility.\n.\nBecause NumPy is so widely adopted and presents one of the biggest stumbling blocks for PyPy users, PyPy’s developers forked NumPy and created a PyPy-compatible version called .. Consider this the exception, not the rule—you’d need a lot of manpower to create PyPy-compatible forks of even a fraction of the packages that depend on C extensions.\n.\nWhich version will win out for PyPy users: NumPy or NumPyPy? According to the developers, both have their merits: “There are places where gcc can beat the JIT, and places where the tight integration between NumPyPy and PyPy is more performant,” states developer Richard Plangger in the PyPy blog. Rather than boost one over the other, PyPy is planning to “integrate both [NumPy and NumPyPy], hijacking the C-extension method calls to use NumPyPy where we know NumPyPy can be faster.”\n.Serdar Yegulalp is a senior writer at InfoWorld, focused on machine learning, containerization, devops, the Python ecosystem, and periodic reviews..Copyright © 2016 IDG Communications, Inc.",
        "Freenove Raspberry Pi 4B3B RFID starter kit, Python C Java/204 item/53 project",
        "",
        "Is it better to learn R or Python for a career as a data analyst? Learn more about how to choose the best statistical programming language for your career goals..If you’re getting started in data analysis, you’ll find that one of the most important skills is proficiency in a statistical programming language. . use SQL (Structured Query Language) to communicate with databases, but when it comes to cleaning, manipulating, analyzing, and visualizing data, you’re looking at either Python or R..Both Python and R are free, open-source languages that can run on Windows, macOS, and Linux. Both can handle just about any ., and both are considered relatively easy languages to learn, especially for beginners. So which should you choose to learn (or learn first)? Before we dig into the differences, here’s a broad overview of each language. .Python is a high-level, general-purpose programming language known for its intuitive syntax that mimics natural language. You can use Python code for a wide variety of tasks, but three popular applications include:.Data science and data analysis.Web application development.Automation/scripting. .A high-level programming language features a syntax that is easy for humans to read and understand. Low-level languages are those that can be easily understood by a machine. Examples of high-level languages include Python, C++, C#, and Java..When you write code in a high-level language, it gets converted into a low-level language, or machine code, that your computer can recognize and run..R is a software environment and statistical programming language built for statistical computing and data visualization. R’s numerous abilities tend to fall into three broad categories:.Manipulating data.Statistical analysis.Visualizing data .Hear more about what R can do from Carrie, a data analyst at Google..There’s no wrong choice when it comes to learning Python or R. Both are in-demand skills and will allow you to perform just about any data analytics task you’ll encounter. Which one is better for you will ultimately come down to your background, interests, and career goals. .As you make your decision, here are some things to consider..According to several popular programming language indices, TIOBE [.], Stack Overflow [.], PYPL [.], and RedMonk, [.] Python is far and away the more popular language across the broader tech community. .While this doesn’t necessarily mean it’s better, it does suggest that it’s more widely used and may have a more robust community for ongoing support and development..Both Python and R are considered fairly easy languages to learn. Python was originally designed for software development. If you have previous experience with Java or C++,  you may be able to pick up Python more naturally than R. If you have a background in statistics, on the other hand, R could be a bit easier..Overall, Python’s easy-to-read syntax gives it a smoother learning curve. R tends to have a steeper learning curve at the beginning, but once you understand how to use its features, it gets significantly easier. . Once you’ve learned one programming language, it’s typically easier to learn another one. .In general, it’s a good idea to “speak” the same language as the team you’ll be working with. This makes it easier to share code and collaborate on projects. .If you’re just starting out, you may not know what company you’ll eventually work for. Take a look at a few job listings for the companies and industries you’re most interested in. Do they tend to list R or Python as a requirement? This could be a good indication for which direction to take your learning..While both Python and R can accomplish many of the same data tasks, they each have their own unique strengths. If you know you’ll be spending lots of time on certain data tasks, you might want to prioritize the language that excels at those tasks..Think about how learning a programming language fits in with your longer term career goals. If you’re passionate about the statistical calculation and data visualization portions of ., R could be a good fit for you..If, on the other hand, you’re interested in becoming a . and working with big data, artificial intelligence, and deep learning algorithms, Python would be the better fit. .The same is true if your personal or professional interests extend beyond data and into programming, development, or other computer science fields. Python is a general-purpose language used for a much wider range of tasks than R..Python and R are both excellent languages for data. They’re also both appropriate for beginners with no previous coding experience. Luckily, no matter which language you choose to pursue first, you’ll find a wide range of resources and materials to help you along the way. These are just a few options for getting started..Earning a . or . gives you a framework for learning a statistical programming language within the greater context of data analysis. The Google certificate teaches R, and the IBM certificate teaches Python. Both include other job-ready skills, like SQL, spreadsheets, and data visualization. Not only can you learn to program, you can learn how all these critical data skills work together..If you’re interested in starting a career as a data analyst, these programs are a great way to build your foundation through videos, assessments, interactive labs, and portfolio-ready projects. Both can be completed in less than six months..If you prefer focusing on one skill at a time (or if you’re adding a new coding language to your existing data analyst skill set), a course in Python or R could get you started. There are a ton of classes out there to choose from. On Coursera, the most popular options among learners are . from the University of Michigan and . from Johns Hopkins University.. For many learners, it may be better to pick one language and get proficient rather than trying to learn both at the same time. .Another great way to decide whether to learn R or Python is to try them both out. Coursera’s Guided Projects offer a hands-on introduction in under two hours without having to buy or download any software. .With ., you can start writing basic R commands and learn how to install packages and import data sets. With ., which takes under an hour to finish, you can write a guessing game application as you learn to create variables, decision constructs, and loops..Instead of measuring each programming language in terms of demand, it can help to know which is most popular because that may indicate greater job prospects, more robust libraries, and increased community support. .While Python is the more popular language of the two, it’s a good idea to review job postings to see which language is preferred or required. \n. .‎.There’s a reason Python is so popular as a programming language. It’s considered easy to learn and its multi-purpose structure makes it applicable to a wide variety of needs. .R, on the other hand, was built by statisticians to serve more specialized uses, so it may be more difficult to learn at first, though it’s considered a relatively easy language overall. \n. .‎.SQL is another standard programming language for data analysts. Other languages analysts may use include JavaScript, Scala, Java, Julia, and C/C++.. .‎.It’s generally a good idea to know more than one programming language to increase your versatility and competitiveness. Luckily, it's often easier to learn a new language once you’ve mastered another.. .‎.1. TIOBE. \"., https://www.tiobe.com/tiobe-index/.\" Accessed April 12, 2021..2. Stack Overflow. \"., https://insights.stackoverflow.com/survey/2020.\" Accessed April 12, 2021..3. GitHub. \"., https://pypl.github.io/PYPL.html.\" Accessed April 12, 2021..4. RedMonk. \"., https://redmonk.com/sogrady/2021/03/01/language-rankings-1-21/.\" Accessed April 12, 2021..This content has been made available for informational purposes only. Learners are advised to conduct additional research to ensure that courses and other credentials pursued meet their personal, professional, and financial goals.",
        "As PyData leverages much of the static language world for speed including CUDA, we need tools which not only profile and measure across languages but also devices, CPU, and GPU.  While there are many great profiling tools within the Python ecosystem: line-profilers like . and profilers which can observe code execution in C-extensions like ./..  None of the Python profilers can profile code running on the GPU.  Developers need tooling to help debug/profile and generally understand what is happening on the GPU from Python.  Fortunately, such tooling exists — . and .together are powerful tools for visualizing CPU and GPU performance..NVTX is an annotation library for code in multiple languages, including Python, C, C++.  We can use Nsight Systems to trace standard Python functions, PyData libraries like Pandas/NumPy, and even the underlying C/C++ code of those same PyData libraries!  Nsight Systems also ships with additional hooks for CUDA to give developers insight to what is happening on the device (on the GPU).  This means we can “see” CUDA calls like ., ., etc..NVTX is a code annotation tool and can be used to mark functions or chunks of code.  Python developers can either use decorators .or a context manager . to mark code to be measured.  For example:.Annotating code by itself doesn’t achieve anything. To get information about the annotated code, we typically need to run it with a third-party application such as.. In the above, we’ve annotated a function, . and a for loop.  We can then run the program with Nsight Systems CLI:.The option . defines what nsys should capture.  In this case, nvtx annotations and OS RunTime (OSRT) functions (read/select/etc)..After both . and the python program finish, two files are generated: a . file and a sqlite database.  We can visualize the timeline of the workflow by loading the . file with Nsight Systems UI (available on all OSes).At first glance this isn’t the most exciting profile — the code itself is uncomplicated.  But unlike other profiling tools, this view is a timeline.  This means we can better evaluate end-to-end workflows and introspect code as the workflow proceeds and not just how much time total we speed in ..  Though nsys also present that view as well.Like ., NVTX can also profile across .. .We can then run the program with Nsight Systems CLI:.In this example, we create two processes to create a large amount of data and compute the mean.  In the first process we build a 4096×4096 matrix of random data and in the second process, a 1024×1024 matrix of random data.  What we see in the visualization are two red bars (noting the data creation time and 3 blue bars (though admittedly the blue bar attached to the small red data generation task is hard to see).  We see two very informative things here which can be hard to capture in tools which only measure time spent:.An Nsight Systems’ feature called “NVTX range protection allows user to annotate across devices, specifically NVIDIA GPUs.  This means we can develop a deep understanding of not just what is happening on the GPU itself (cudaMalloc, Compute Time, Synchronization), but also leverage the GPU from Python in a diverse, complicated, multi-threaded, multi-process, multi-library landscape.  Again, let’s ease our way in..We use ., a NumPy-like library targeting GPUs, to operate on the data just as we do with NumPy data. The figure above captures how long we spend allocating data on the GPU.We can also see the execution of individual cupy kernels: ., . as well as where and when the kernels are executed relative to other operations.The example below calculates the squared difference between two matrices and measures the time spent performing this calculation:.With this information, we can now visually understand how and where the GPU spends time.  Next, we can ask, can we do better?  The answer is YES! . is a non-zero time operation and creating many GPU allocations can negatively impact performance.  Instead, we can use the . pool allocator which will create a large upfront GPU memory allocation and allow us to make sub-allocations at significantly faster speeds:.For this particular operation, ., we can use . to optimize elementwise kernels.  This is a common GPU optimization..The annotations themselves have minimal overhead and only capture information when executed with .. Profiling code provides useful information to users and developers that is otherwise hidden and reveals much about where and why time is being spent.  When library authors choose to annotate with NVTX, users can develop a more complete understanding of end-to-end workflows  For example, with RAPIDS cuDF, a GPU Dataframe library, kernels will often need to allocate memory as part of group by-aggregation.  As we saw before using the RMM pool allocator will reduce the amount of time spent creating GPU memory:.We can also quickly see why some equivalent operations are faster than others depending on the route taken. When performing several groupby-aggregations . we can either perform each individually or use the . operator. Using . will only perform the groupby operation once..In the plot above we see more than the . and . annotations. We see the annotations inserted by cuDF developers and can clearly see one . call for . and three . calls for .Currently, annotating a function within a package requires users to make modifications to that package, or convince the maintainer(s) to annotate parts of the package. It would be convenient to be able to annotate a function without modifying its source code. It’s not immediately clear how to achieve this..Another potentially useful feature would be to annotate execution threads. Currently, the different threads of execution are named . etc., which may not be as useful. This is already possible in the C layer, but not exposed in the Python layer currently..While these are just a few thoughts on our minds, we would welcome suggestions from the community. We maintain . with the C, C++, and Python bindings and would welcome issues on the .. If there are things missing, we . and are happy to review. Also, just drop by and say hi, we have a . as well..It’s easy to download NVTX using pip or conda:.or:.The examples from this blog post (and a few others) are available at this .. ",
        "If there is one persnickety thing people ask of python-dev it is for the . to go away. People view it as this great bugaboo of performance that hinders CPython in a world where single-core chips are becoming extremely rare. Whether the GIL is really a performance killer as some people believe (it really depends on the type of work you want to run in parallel), the GIL's shadow does linger over CPython..If you read the LWN writeup on the PyCon 2015 language summit entitled . you will notice that the topic of removing the GIL in Python 3 did come up. But you will notice that there was one consistent theme in the discussions regarding the GIL: extension modules would need to change in some form. Even the least invasive suggestion of making sub-interpreters work could possibly require some extension modules to be reworked in order to be re-entrant. Other approaches that focused more on removing reference counting and switching to garbage collection required  more changes that ranged from the mechanical -- e.g., adding a parameter on every function -- to even deeper changes that are not as mechanical..The key point is that ridding CPython of the GIL requires at least \"bending\" the C API -- as Larry Hastings has explained it is having to tweak the murky corners of extension module code -- if not full-out changes of how extension modules work that will require code changes for everyone. To illustrate how the C API can hinder things, Larry told me a story about how PyPy has changed garbage collection schemes three times. Now if PyPy had a C API that they directly exposed to users like CPython has they would not have been able to change their garbage collection scheme without breaking extension modules (he told the story in .). It's this kind of inflexibility that the C API forces upon CPython that makes removing the GIL cleanly basically impossible..What all of this means is that if you want to try and shield yourself from any potential bending of the C API that could occur in the future in order to get rid of the GIL then I would recommend not using CPython's C API directly and instead use a library that will assist you (this will also help you transition to Python 3). Which one you use will depend on why you want to use CPython's C API in the first place..If you wanted to use CPython's C API in order to call other C code such as some C library, then I would recommend looking at .. It's the most straight-forward for wrapping C code and it is explicitly designed for interfacing with C code. It also has the benefit of working with both PyPy and CPython..You can also use . or . to wrap the C code you want to interface with. In either case, though, PyPy compatibility won't be quite as good and it does require working in a . that some people might not like..If you're using CPython's C API for performance then what you want to use will depend on whether you are using . in your code. If you are then you should see if . fits your needs. It will apply a JIT to your NumPy code by doing nothing more than adding a decorator to some functions which is about as easy as it can get..If your performance needs extend beyond Numba, then . will be your best bet. While you will need to write in Cython's hybrid language, it will probably be the easiest way to get better performance short of writing C code directly..If writing C code for performance appeals to you then you can use . or . to wrap your hand-rolled C code. But please do consider Numba and/or Cython first as they will be easier to use for good performance gains..The key takeaway I hope people have from this is that you should use a library/tool to help you interface Python with C code, whether it's for performance or FFI needs. While the C API for CPython helped it gain its reputation as a great glue language, that doesn't mean you need to continue to work with it directly with so many great projects out there to help make your life easier. So please consider one of the libraries/tools I mentioned the next time you start a new project that involves some C code and do consider tossing your hand-rolled code to make maintenance easier for you.",
        "",
        "22 Jan 2019,  .\nWith python being used in many machine learning applications, serverless frameworks, etc.\nas the go-to language, we believe a Crail client Python API would be a useful tool to\nbroaden the use-case for Crail.\nSince the Crail core is written in Java, performance has always been a concern due to\njust-in-time compilation, garbage collection, etc.\nHowever with careful engineering (Off heap buffers, stateful verbs calls, ...)\nwe were able to show that Crail can devliever similar or better performance compared\nto other statically compiled storage systems. So how can we engineer the Python\nlibrary to deliver the best possible performance?\n.\nPython's reference implementation, also the most widely-used, CPython has historically\nalways been an interpreter and not a JIT compiler like PyPy. We will focus on\nCPython since its alternatives are in general not plug-and-play replacements.\n.\nCrail is client-driven so most of its logic is implemented in the client library.\nFor this reason we do not want to reimplement the client logic for every new\nlanguage we want to support as it would result in a maintance nightmare.\nHowever interfacing with Java is not feasible since it encurs in to much overhead\nso we decided to implement a C++ client (more on this in a later blog post).\nThe C++ client allows us to use a foreign function interface in Python to call\nC++ functions directly from Python.\n.\nThere are two high-level concepts of how to integrate (C)Python and C: extension\nmodules and embedding.\n.\nEmbedding Python uses Python as a component in an application. Our aim is to\ndevelop a Python API to be used by other Python applications so embeddings are\nnot what we look for.\n.\nExtension modules are shared libraries that extend the Python interpreter.\nFor this use-case CPython offers a C API to interact with the Python interpreter\nand allows to define modules, objects and functions in C which can be called\nfrom Python. Note that there is also the option to extend the Python interpreter\nthrough a Python library like ctypes or cffi. They are generally easier to\nuse and should preserve portability (extension modules are CPython specific).\nHowever they do not give as much flexibility as extension modules and incur\nin potentially more overhead (see below). There are multiple wrapper frameworks\navailable for CPython's C API to ease development of extension modules.\nHere is an overview of frameworks and libraries we tested:\n.In this blog post we focus on the overhead of calling a C/C++ function from Python.\nWe vary the number of arguments, argument types and the return types. We also\ntest passing strings to C/C++ since it is part of the Crail API e.g. when\nopening or creating a file. Some frameworks expect . when passing a string\nto a underlying ., some allow to pass a . and others allow both.\nIf C++ is supported by the framework we also test passing a . to a\nC++ function. Note that we perform all benchmarks with CPython version 3.5.2.\nWe measure the time it takes to call the Python function until it returns.\nThe C/C++ functions are empty, except a . statement where necessary..The plot shows that adding more arguments to a function increases runtime.\nIntroducing the first argument increases the runtime the most. Adding a the integer\nreturn type only increased runtime slightly..As expected, cytpes as the only test which is not based on extension modules\nperformed the worst. Function call overhead for a function without return value\nand any arguments is almost 300ns and goes up to 1/2 a microsecond with 4\narguments. Considering that RDMA writes can be performed below 1us this would\nintroduce a major overhead (more on this below in the discussion section)..SWIG and Boost.Python show similar performance where Boost is slightly slower and\nout of the implementations based on extension modules is the slowest.\nCython is also based on extension modules so it was a surprise to us that it showed\nthe best performance of all methods tested. Investigating the performance difference\nbetween Cython and our extension module implementation we found that Cython makes\nbetter use of the C-API..Our extension module implementation follows the official tutorial and uses\n. to parse the arguments. However as shown below we found that\nmanually unpacking the arguments with . already significantly\nincreased the performance. Although these numbers still do not match Cython’s\nperformance we did not further investigate possible optimizations\nto our code..Let’s take a look at the string performance. . and . is used whereever\napplicable. To pass strings as bytes the ‘b’ prefix is used..Again Cython and the extension module implementation with manual unpacking seem to\ndeliver the best performance. Passing a 64bit value in form of a .\npointer seems to be slightly faster than passing an integer argument (up to 20%).\nPassing the string to a C++ function which takes a .\nis ~50% slower than passing a ., probably because of the\ninstantiation of the underlying data buffer and copying however we have not\nconfirmed this..One might think a difference of 100ns should not really matter and you should\nanyway not call to often into C/C++. However we believe that this is not true\nwhen it comes to latency sensitive or high IOPS applications. For example\nusing RDMA one can perform IO operations below a 1us RTT so 100ns is already\na 10% performance hit. Also batching operations (to reduce amount of calls to C)\nis not feasible for low latency operations since it typically incurs in wait\ntime until the batch size is large enough to be posted. Furthermore, even in high\nIOPS applications batching is not always feasible and might lead to undesired\nlatency increase..Efficient IO is typically performed through an asynchronous\ninterface to allow not having to wait for IO to complete to perform the next\noperation. Even with an asynchronous interface, not only the latency of the operation\nis affected but the call overhead also limits the maximum IOPS. For example,\nin the best case scenario, our async call only takes one pointer as an argument so\n100ns call overhead. And say our C library is capable of posting 5 million requests\nper seconds (and is limited by the speed of posting not the device) that calculates\nto 200ns per operation. If we introduce a 100ns overhead we limit the IOPS to 3.3\nmillion operations per second which is a 1/3 decrease in performance. This is\nalready significant consider using ctypes for such an operation now we are\ntalking about limiting the throughput by a factor of 3..Besides performance another aspect is the usability of the different approaches.\nConsidering only ease of use . is a clear winner for us. However it only\nsupports to interface with C and is slow. ., . and .\nrequire a similar amount of effort to declare the interfaces, however here\n. clearly wins the performance crown. Writing your own .\nis feasible however as shown above to get the best performance one needs\na good understanding of the CPython C-API/internals. From the tested approaches\nthis one requires the most glue code..All tests were run on the following system:.The source code is available on .Apache Crail is an effort undergoing . at ., sponsored by the Apache Incubator PMC. Incubation is required of all newly accepted projects until a further review indicates that the infrastructure, communications, and decision making process have stabilized in a manner consistent with other successful ASF projects. While incubation status is not necessarily a reflection of the completeness or stability of the code, it does indicate that the project has yet to be fully endorsed by the ASF.\n            ",
        "The brand new service which powers Ideone!.Widget for compiling and running the source code in a web browser!.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n",
        "Suppose, input is a and b..\nand output will be like,.\na + b = (summation of a and b).\na - b = (subtraction of a and b).\na * b = (multiplication of  a and b).\na / b = (Division of a and b).\nNote:. and normally i’ve to use \\n to create newline..\nIf i write this in C  then it;ll be like:.And output is correct here:.Here,i can control every output by %d inside . function.But, how i’ll write this in python just using one print function..\ni try it ,but failed..\nMy code in python:.if i input 5 as a and 2 as b then,output look like,.That means, . not work in python .\nBut,How can i fix this?.Python is maddeningly cavalier with typecasting. When dividing an integer by another integer, Python automatically promotes the result to a float..To get the expected behavior for those of us from a C background, use floor division, ...Actually,i don’t get this concept yet.Can you please explain it more?.No problem..Consider the following code:.C.Python.You get the following results.C.Python.In C, an arithmetic operation between two integers will return an integer..In Python, addition, subtraction, and multiplication between integers returns an integer, but division between two integers returns a float. You specifically have to use the integer division operation . to get an integer back..Hello Plabon..The way I have always done it is:.Hope this helps.Yes it is!!!.Thank you so much Shaun . . .Thank you so much Bob .This topic was automatically closed 180 days after the last reply. New replies are no longer allowed.",
        " .Blue Yonder has few projects in which few segments of code are in Python and few in C++ and hence it makes for an important use case to find some methodology to make these two languages communicate with each other efficiently. It is extremely crucial to find a tool for Python’s seamless integration with the code written in C++..Before diving deeper into how to access C++ code from Python, let us try and understand why or under what circumstances would we want to do that:. that you’d like to take advantage of in Python. This may be a communication library or a library to solve a specific purpose in the project.. by converting a critical section to C++. Not only does C++ have faster execution speed, but it also allows you to break free from the limitations of the Python Global Interpreter Lock (GIL).. to do large-scale testing of their systems..One of the method to access C++ code from Python is to write a python interface and place python bindings on it in order to give python access, we can do that or use a pre-built tool such as Boost.Python library which is much easier to do.  But before going into details of this method let’s see what are the possible ways of combining Python and C++..There are two basic models for combining C++ and Python:. in which the end-user launches the Python interpreter executable and imports Python extension modules written in C++. It’s like taking a library written in C++ and giving it a Python interface so Python programmers can use it. From Python, these modules look just like regular Python modules. Extending is writing a shared library that the Python interpreter can load as part of an import statement.. in which the end-user launches a program written in C++ that in turn invokes the Python interpreter as a library subroutine. It’s like adding scriptability to an existing application. Embedding is inserting calls into your C or C++ application after it has started up in order to initialize the Python interpreter and call back to Python code at specific times..Note that even when embedding Python in another program, extension modules are often the best way to make C/C++ functionality accessible to Python code, so the use of extension modules is really at the heart of both models. Embedding takes more work than extending. Extending gives you more power and flexibility than embedding. Many useful python tools and automation techniques are much harder, if not impossible, to use if you’re embedding..Boost.Python library discussed above is used to quickly and easily export C++ to Python such that the Python interface is very similar to the C++ interface. Due to its advantage of being fast and convenient to be able to extend C++ libraries to Python we’ll be learning about it in this blog and how we can use it to make Python and C++ talk to each other. But before learning about it lets first find out what is Python Binding and why is it required..Binding generally refers to a mapping of one thing to another. In the context of software libraries, bindings are wrapper libraries that bridge two programming languages, so that a library written for one language can be used in another language. Many software libraries are written in system programming languages such as C or C++. To use such libraries from another language, usually of higher-level, such as Java, Common Lisp, Scheme, Python, or Lua, a binding to the library must be created in that language, possibly requiring recompiling the language’s code, depending on the amount of modification needed. Python bindings are used when an extant C or C++ library written for some purpose is to be used from Python..To understand why Python bindings are required let’s take a look at how Python and C++ store data and what types of issues this will cause. C or C++ stores data in the most compact form in memory possible. If you use an uint8_t, then the space required to store it would be 8 bits if we don’t take structure padding into account..In Python, on the other hand, everything is an object and the memory is heap allotted, integers in Python are big integers and their size may vary according to the value stored in them. This means that our Python bindings will need to convert a C/C++ integer to a Python integer for each integer passed across the boundary..The process of transforming the memory representation of an object to a data format suitable for storage or transmission is called marshalling and Python bindings are doing a process similar to marshalling when they prepare data to move it from Python to C or vice versa..The Boost.Python Library is a open source framework for interfacing Python and C++. It allows you to quickly and seamlessly expose C++ classes functions and objects to Python, and vice-versa, using no special tools, just your C++ compiler. It is designed to wrap C++ interfaces non-intrusively, so that you should not have to change the C++ code at all in order to wrap it, making Boost.Python ideal for exposing 3rd-party libraries to Python. The library’s use of advanced metaprogramming techniques simplifies its syntax for users, so that wrapping code takes on the look of a kind of declarative interface definition language (IDL)..The Boost.Python Library binds C++ and Python in a mostly seamless fashion. It is just one member of the boost C++ library collection at .. Boost.Python bindings are written in pure C++, using no tools other than your editor and your C++ compiler..Python (more specific: CPython, the reference implementation of Python written in C) already provides an API for gluing together Python and C in the form of Python C API. Boost.Python is a wrapper for the Python/C API..Using the Python/C API, you must deal with passing pointers back and forth between Python and C and worry about pointers hanging out in one place when the object they point to has been thrown away. Boost.Python takes care of much of this for you. In addition, Boost.Python lets you write operations on Python objects in C++ in OOP style..So now that we are done with the theoretical aspects of it, let’s get our hands dirty with some coding and see how it can be used through a short example..To try it out yourself, check out this . with basic build and execute instructions..Before we get to the actual coding part let’s see what the prerequisites are to run a program with a boost library:. (version >= 1.3.2). (version >= 2.2).A C++ compiler for your platform, e.g. . or .Suppose we have the following C++ API which we want to expose in Python:.Here is the C++ code for a python module called getting_started1 which exposes the API..That’s it! If we build this shared library and put it on our PYTHONPATH we can now access our C++ functions from Python..So, as you can see from the example above the only additional library required to run our program is the Boost library apart from the regular C++ and Python compiler and all you need to do is compile and build the C++ library and import it in Python as a regular Python library and boom you’re ready to go..Now that we have explored running a simple Hello World program in Python which is written in C++, let’s see how we can do the same with C++ struct/classes through an example..Assume we want to expose the below written C++ struct/class to Python..The corresponding Python code to call the above C++ class from Python would be:.The output of running the above code would be:.This is just the tip of the iceberg and there could be several use cases for making the two languages talk, especially while taking the edge of data science in the existing projects or while using the best features of both the languages. Although Boost.Python is a great tool for a quick start up, it has a few drawbacks like packaging projects where native dependencies could be challenging. Also, since it’s a python run-time dependency resolution it might be difficult to use all the C++ features, especially templates. But, having said that, it’s a great tool for getting started and running at least the basic C++ code as python libraries. With Boost.Python you can open up possibilities to a whole new world..\n.\n.Coiled Webinar “Science Thursday”: Data Processing at Blue Yonder - One Supply Chain at a Time\n\n.\n.\n.The Sunk Cost Fallacy\n\n.\n.\n.Java: Giants and Infinite Loops\n\n.\n.\n.Introducing Cube Functionality To Kartothek\n\n",
        "",
        "Something went wrong. Wait a moment and try again.",
        "",
        "\n.\n.jobs per page: .sort by: .\r\n                            Success! Randstad currently has 142 python c developer jobs in , Florida. These postings include  python c developer job openings for a variety of skill sets in , Florida. Check out the list of available jobs below and find your new python c developer job today! \r\n                        .\r\n                            Found your dream job but don't know where to start? Get tips from our experts about \r\n                            .\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n",
        "\n        Master the world's most popular programming languages with this training bundle. You'll also learn about Raspberry Pi and artificial intelligence.\n    .It's no secret that learning how to code is one of the most important things you can do if you want to .. Whether you're primarily interested in creating best-selling apps or pro-level websites, you need to be well versed in the programming languages and platforms that are used by today's most competitive developers. .But if you want to stand out from the crowd and get a great tech job, you need to know more than just one or two programming languages. The . will get you up to speed with the world's most popular and powerful programming languages and scripts so you can have a successful career as a developer. The entire training bundle is available for over 95% off at just $59.99 right now. .With 27 courses and 26 hours of instruction led by industry pros, this best-selling bundle is your one-stop resource for mastering Java, MySQL, Swift, and more. There's also plenty of instruction that walks you through the basics and more advanced elements of Python. In addition, other courses include: How to create apps by utilizing JavaScript's advanced elements and protocols, integrate comprehensive UIs into your websites using powerful scripting protocols, and work with Ruby to create a wide range of applications for desktop and mobile devices. .Get the skills and tools you need in order to become an in-demand developer this year with help from the Premium Learn to Code 2021 Certification Bundle while it's available for .—over 95% off its usual price for a limited time. . ",
        "",
        "\n                    Created 16 February 2009, last updated 28 January 2021\n                .This is a presentation for PyCon 2009 in Chicago.\nA .\nis available on pyvideo.org, or at\n.,\nor right here:.Python can be extended with extensions written in C. It’s a complex topic,\nthis will be a quick 45 minute introduction.\n.The examples here are toys, meant to demonstrate the structure of an\nextension. They are real running code, but they don’t do anything useful.\nThey’ll demonstrate the workings of the C API and modules written with it. I’m\nassuming you’ll be able to provide your own domain-specific inner workings.\n.I’m assuming you know Python, and that you know C, at least well enough to\nfollow along..The code samples are available in\n...Why write in C when we have lovely Python?.There are other tools that solve similar problems:.The C API is actually the public interface to the implementation of CPython.\nIt’s the same API used internally to build Python itself.  It’s large, with over\n600 entry points covering all sorts of functionality.\n.Because it’s the core of CPython, it doesn’t apply to other implementations\nof Python: Jython, IronPython, PyPy, etc.\n. is a project to provide\nfor C extensions in IronPython, but I have no experience with it..One amazing advantage to writing against the same C API as the core Python\ndevelopers is that their code can be your learning sample.  Want to do something\nsimilar to a built-in function? Go find its source and learn how it was done.\n.Writing a C API extension means working in two worlds at once. The C\nenvironment you’re coding in is missing many of the niceties you’re used to in\nPython, and at the same time, you’re writing code that provides those niceties\nto your callers..This is the Python code for the module we’ll implement in C.  It contains a\nsingle function which simply returns the string “hello world!”.  Both the module\nand the function have doc strings..This is the complete C code for the Hello World extension:.The file starts by including Python.h.  This pulls in all of the\ndefinitions needed for using the C API, as well as a few standard header\nfiles..Next comes the hello_world function itself, that will actually do the work\nof the extension. The signature of the function is typical for the C API. There\nare few different ways to invoke C functions from Python, but this signature is\nthe most common: taking two PyObject pointers, and returning another one..The hello_world function is very simple, it just returns a constant Python\nstring.  We use the function Py_BuildValue to create a Python string from a C\nstring.  In this case, the C string is a literal, but any C string can be used.\nPy_BuildValue’s first argument is a format specifier that indicates how to\ninterpret the rest of the arguments, similar to how sprintf works. In this case,\nthe format spec is simply “s”, meaning the argument is a C string to be turned\ninto a Python string..The hello_world function is defined to return a PyObject*, so it returns the\nobject created by Py_BuildValue.  Even functions that return nothing must\nexplicitly return a None value.  Returning NULL indicates that an exception occurred,\nwhich we’ll get to later..Because C has no introspection or reflection facilities, just defining the\nhello_world function isn’t enough for us to be able to use it by name.  Next comes\nan array of PyMethodDef structures which will define the contents of the module.\nEach structure specifies a function, providing the Python name, the C implementation\nfunction, flags indicating how the function should be called, and a doc string.\n.In our case we have only one function. We’ve named the C function hello_world,\nthe same as its Python name, but the connection between the two is made by the\nstructure associating the hello_world C function with the Python name “hello_world”,\nnot the identical names..The flags for hello_world are METH_VARARGS which tells Python how to invoke\nthe C function.  Last comes the doc string for the function, as a standard C\nstring. The array is terminated by a sentinel structure with a NULL name\npointer, a common C idiom..The last function defined here is initext1, and it’s the only symbol exported\nfrom this file (the others are declared static).  This function is executed when\nthe module is imported, and its name is important.  It must be named initMOD where\nMOD is the name of the module, otherwise Python won’t be able to find it in the\nexecutable library..Our initext1 function only does one thing: initialize the module by calling\nPy_InitModule3 with three arguments: the name of the module, the table of function\ndefinitions for the module’s contents, and a doc string for the module..This simple extension shows the typical structure of a C API extension:.Building the extension is easy: setup.py knows how to do it with a simple\ndeclarative statement.  All we have to do is tell distutils about our extension:\nwhat it is called and what source files comprise it.  Distutils knows how to do\nthe rest, producing a .pyd file on Windows, or a .so on Linux.\n.On Windows, it may take some work to get a compiler installed properly.\n.Once built and installed, the module works like any other Python module. The\nfunction can really be called, and so on. Notice that hello_world’s type is\n“built-in function”. Your code really is no different than a truly built-in\nfunction, they are both written with the same C API, and called in the same way.\nTo the Python interpreter, your hello_world is the same as, say, len..The C API is fairly consistent in its conventions, but there are a few of\nthem, so read the docs to be sure you know how each function works.  The docs\nare good, and say what will happen..The C API provides hundreds of entry points..Each built-in type has a set of C calls that implement the operations particular\nto the type.  They’ll look familiar to you from working with the types in Python.\nIn some cases, the operations may be made available in slightly different forms,\nsuch as PyDict_SetItem, which uses a PyObject as a key, and PyDict_SetItemString,\nwhich uses a C string as a key.  The latter is provided because using strings as\nkeys is so common, it is special-cased for the caller and in the dictionary\nimplementation..The C API also provides polymorphic functions that access objects based on\nwhat they do rather than what they are..And on and on, covering all of the built-in functionality of the Python\nenvironment..We used Py_BuildValue to create the Python “hello world” string. It can make\nmany other Python data structures. The format string can include punctuation that\ncreates tuples, lists, and dictionaries, including nesting:.You’ll use Py_BuildValue quite a bit to create Python data to return from your\nextension..Just as Py_BuildValue makes it easy to combine C values into a Python structure,\nPyArg_ParseTuple makes it simple to parse apart a tuple into a number of C\nvariables.  The args argument to our C functions contains a tuple of the arguments\nto the function call.  We pass it to PyArg_ParseTuple along with a format string\nindicating what types we expect.  PyArg_ParseTuple works like sscanf, interpreting\nthe format string, and assigning values to the variables in the rest of its arguments.\n.Here we get a C string and a C integer from the Python values passed in. Just\nas with sscanf, the arguments after the format string must be addresses of variables\nthat will be assigned values:.In this code, we can use typical C pointer arithmetic to get the index’th\ncharacter from the string, and then use Py_BuildValue to return it as a Python\ninteger..If you try passing incorrect arguments to our string_peek function, you’ll\nsee it behaves as you would expect a Python function to, raising exceptions\nabout incorrect types and number of arguments:.We get all this free from PyArg_ParseTuple, all we have to do is pass along\nerrors it detects..If the args tuple doesn’t consist of a string and an integer, PyArg_ParseTuple\nwill set an error state, and return false. The “:string_peek” portion\nof the format string tells PyArg_ParseTuple what function name to use in its\nerror messages..If PyArg_ParseTuple returns false, we know that the arguments weren’t proper,\nand we simply return NULL from the function.  This indicates to Python that an\nexception occurred, and it will raise it in the Python environment..The error state is global — once set by PyArg_ParseTuple, all you\nhave to do is return NULL, and the Python interpreter will raise the error as\nan exception in the calling Python code..In Python, the norm is to not catch exceptions, and let called functions’\nexception pass through your code. In C API code, the same rule is true, but is\nimplemented by always checking return codes, and if a called function returns\nfalse or NULL, then you should return NULL to pass the error up the stack..There’s still a problem with our string_peek function: we can ask for the\n2000’th character of a nine-character string. Our C code happily reads the\ncontents of memory far outside the actual string it’s supposed to be working\nwith..We can check the index value to see that it’s valid for the string, then\nraise our own exception if it is not.  To raise an exception in the C API,\ncall PyErr_SetString to set the error state, and return NULL to indicate to\nPython that an exception occurred.  PyErr_SetString takes two arguments: the\nexception type, and a string message for the exception.\n.Once we’ve done that, out-of-range arguments to string_peek will raise\nPython exceptions as you’d expect:.Python’s memory management is based on reference counting.  Every Python object\nhas a count of the number of references to the object.  When the count becomes\nzero, the object can be destroyed and its memory reclaimed..In the C API, Python objects are instances of PyObject, and references to them\nare PyObject pointers.  When using PyObject pointers, you have to manipulate\nreference counts properly, or your extension will leak memory or crash..Every PyObject pointer is either owned or borrowed.  They are both pointers,\nused like any other C pointer.  But an owned reference means you are responsible\nfor correctly disposing of the reference. Remember, objects are not owned, they\nare all shared, it’s references to objects that are owned or borrowed..A borrowed reference means you can identify some other piece of code that\nowns the reference, because that code’s interest in the object started before\nyours, and will end after yours.  For example, a caller must have a reference to\nthe args it passes into a called function, so arguments are almost always borrowed..If you get it wrong, the object will be freed out from under you: crash!.There are two ways to get an owned reference:.Once you have an owned reference, you have to get rid of it properly.  The\nthree ways are:.Let look at a real code example:.In this code, we have four PyObject pointers:\n.We have to make sure that we properly dispose of our owned reference, which\nhappens at line 23 when we return it as the value of the function, passing the\nownership to our caller..But there is a memory leak in this code: if PySequence_SetItem fails, we\nproperly return NULL from the function to indicate the problem, but in that code\npath, we haven’t disposed of our owned reference, ..\n.Fixing the memory leak is simple: before returning NULL from the function,\ndispose of the owned reference explicitly with Py_DECREF.  Now every path\nthrough the function properly handles the owned references, and our function\nis complete:.Real-world C functions of course can be much more elaborate than this one,\nand analyzing all the code paths can be complex.  One way to simplify the problem\nis to organize your code so that all returns are at the end of the function,\nand resource clean up is all in one place at the end also:\n.Your function’s resources may need more complex logic to get all the owned\nresources released properly, and you may not like the idea of using goto.\nBut organizing code this way will make the code flow clearer, and you can\nconsolidate all your resource tear-down code in one place, making it easier to\nbe sure you have it right.\n.However you organize your code, keeping track of owned references is an\nextra burden for you as you write your extension, but it is extremely important\nto get it right..Making a type is more involved than simply making functions, but it has a\nsimilar flavor: write C components, describe them in arrays, and use the arrays\nto create Python components..The storage for your type is a C struct.  Its fields will be your type’s\ndata:.The first thing in the struct must be PyObject_HEAD, with no semicolon.\nThis is a macro that creates the initial fields in the structure.  This is what\nmakes your structure usable as a PyObject..The rest of the structure can be whatever data you need to support your code.\nPyObject * pointers are very useful for holding Python objects as data, but\nremember they are almost certainly owned references, since you can hold those\nvalues across function calls.  As with all owned references, you have to be\ncareful to acquire and release them properly.\n.When writing a class in Python, special methods have special names, like\n..  When creating a type in C, those special methods\nare ordinary C function with particular signatures that will be specified as\npart of the type definition.  Often, these functions are named systematically\nwith the type name and method name, but as with our earlier C functions, the\nname really doesn’t matter: a pointer to the function will be used to associate\nit with its role..Each type has an init function, which is the analog of .:\nit initializes the data members:.Unlike a Python class, a C class needs an explicit deallocation method.\nHere you should dispose of your owned references, and finally call the class\ntp_free function to clean up the type itself.\n.You can decide which of your struct’s fields to make available as Python data\nattributes, if any.  An array of structures defines the attributes:\n.Each PyMemberDef structure specifies the Python attribute name, the C type\nof the field, the offset into the structure (with the handy offsetof macro),\nsome flags, and a docstring for the attribute.  The array will be used later\nin the type definition.\n.Class methods are defined just like functions.  That strange .\nargument we had on our functions earlier now makes sense: we can declare it to be\nour struct type, and use it to access our data fields:\n.Methods are declared just like functions, in an array of structs providing the\nname, C function pointer, flags, and docstring for the method:\n.Now we are ready to pull all our pieces together.  Types are defined\nby initializing a PyTypeObject struct.  This struct has fields for each of\nthe special functions needed to provide the behavior of a type.  Where in\nPython we’d have specially named functions like __init__ and __hash__, in C\nwe have members in the PyTypeObject struct pointing to the C function\nimplementing the functionality. Other fields in the struct get pointers to the\narrays of structs defining the methods, properties, and attributes:\n.The good news is that most of these fields can be omitted, just as in Python,\nyou only have to implement the special functions you need to override.\n.Finally we are ready to actually create the type. Once the module is initialized,\nwe can init some slots in the type that can’t be done with the struct initializer,\nthen call PyType_Ready to finish up the creation of the type:\n.PyType_Ready performs bookkeeping and other initialization to prepare the type\nfor use, including hooking up the hierarchy for inheritance, and so on.  Finally,\nPyModule_AddObject is used to assign the type to its name in the module, and we\nare done.\n.As you’d expect, our CountDict type works like other built-in types:.We can construct it, examine it, call its methods, and use its attributes,\njust like a Python type..These are other topics that we can’t cover here....Here are some other references, quickly thrown together:",
        "It’s clear that . in the . sphere. More and more engineers, product designers, and developers are starting to use it in their work. Compiling languages are making room for Python in the embedded category..We can’t forget that there is a whole new generation of developers who use Python as a default language for everything from machine learning and scientific experiments to prototyping and data analysis..And even though this is means that Python is pushing C out of its place in the embedded world, that doesn’t mean that they can’t be used together. Developers who are used to working with mostly C over the years may feel the need to defend their position and list all the ways in which C works for them. Or they could join this recent development in the microcontroller world and try a high-level language like Python..That about sums it up, but let’s go more in depth and see how Zerynth tools fit in this picture.. – the bridge between the microcontroller and the Cloud..Imagine this, on one side you have a . based development board and on the other, you have your preferred .. The Zerynth toolset is what connects them to each other..With thousands of users over the world, it’s clear that developers and engineers have recognized the value of Zerynth tools..Furthermore, ., in the same project..This is how it works:.Python is compiled to bytecode and executed by the Zerynth Virtual Machine independently of the target board. On the other hand, C is compiled to object code dependent on the target microcontroller instruction set. These two can coexist because, during the uplinking phase, Zerynth resolves any unresolved symbol from the C code and saves C function addresses in the bytecode..This kind of . is extremely useful in those scenarios where you need to write or you have already written performant low-level code for time-critical tasks, but you want to retain Python flexibility and readability for non-time critical sections..You can mix things up. Code your ., and for all those parts where you need more speed, you can use C..You can learn more about it ...And if after everything you’ve just read now, you’re up for a challenge, you can check out this . on programming the popular ...This . teaches you how to do some basic LED blinking in C/Python with ...You can recreate in on any of the ., so the author of the tutorial has picked the ESP32 DevKit V1..All you need to do now is download .! It’s . . and available for Windows, Linux, and Mac OS.",
        "\n        Should be {http://www.linkedin.com/pub/[member-name/]x/y/z}\n        or {http://www.linkedin.com/in/string}\n      ",
        "No eBook available",
        "",
        "Edited by:.Reviewed by:",
        "",
        "A computer program is a collection of instructions to perform a specific task. For this, a computer program may need to store data, retrieve data, and perform computations on the data..A data structure is a named location that can be used to store and organize data. And, an algorithm is a collection of steps to solve a particular problem. Learning data structures and algorithms allow us to write efficient and optimized computer programs..Our DSA tutorial will guide you to learn different types of data structures and algorithms and their implementations in Python, C, C++, and Java..Programiz offers a complete series of easy to follow DSA tutorials along with suitable examples. These tutorials are targeted for absolute beginners who want to dive into the field of computer programming..Learning from books is always a good practice. You will get the big picture of programming concepts in the book which you may not find elsewhere..Here are some books we personally recommend..Once you have some idea about data structure and algorithms, there is a great resource at . that lets you learn through animation.",
        "Dear Riccardo,.thank you for making me shift attention on this topic once again. As you know, I agree with each single . of your post..I strongly support OOP because . in someway, while a good design is not!.How do you measure the speed, for instance, of an hydrological model: just evaluating the time spent to run the executable or measuring the time spent to adapt the model with the last discovered in research?.I hope in this way to open a discussion here, in this web-page, because I'm really interested in hearing other ideas and opinions about this definitely relevant topic. And this blog is the right place..Best and .!.francesco.f2py library (converts fortran subroutine to python function) makes python supercharged for software evolution purposes. Basic multiprocessing and numpy libraries perform real speed up in calculations that makes python best for common modelling applications. I think that SUMMA framework proposed by M. Clark is the best way for model blocks connection using open API (simpler than OpenMI) - and we will use statically typed languages for solvers and dynamically typed languages for block connections. .I know Martyn work (see: http://abouthydrology.blogspot.it/search/label/Martyn%20Clark). Hower not so deeply..Firstly, thanks Riccardo to making me shift my attention to this topic once again..Unfortunately I do not know anything about python, so I'm not really able to reply to hydrogo in a technical way..However, I can share my small experience in programming environmental models (especially hydrological ones)..Some months ago I had to deal with a monolitic software originally written in .. It was supposed to be fast because of the peculiarities of the language and the algorithms implemented. But modifying it was a nightmare..In this sense, my question is:. the time spent to get results from running the executable or the time you need to adapt the model to the last discoveries in research?.Thus, in my opionion, the speed of a software is something relative, while well thought design is not. Thinking about the ., we can wait some more minutes to get results, but ...Concluding, I believe that . (in the true sense of the words) is what research needs to speed up the modeling evolution. It is not matter of programming language..But I'm an open mind person...so, I'm looking forward to opening an interesting discussion about this topic. And this blog is the right place..Thank again Riccardo for the food for thought..Best,.francesco.This comment has been removed by a blog administrator..This comment has been removed by a blog administrator..Good and interesting information shared here..This comment has been removed by a blog administrator..This comment has been removed by a blog administrator..\n.\n.\n",
        "Get this book in print",
        ""
    ]
}